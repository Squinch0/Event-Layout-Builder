<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Sleeve Events ‚Ä¢ Official Room Planner</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1733;
      --panel2:#0c122a;
      --stroke: rgba(255,255,255,.10);
      --stroke2: rgba(255,255,255,.06);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.65);
      --muted2: rgba(255,255,255,.45);
      --brand:#8b5cf6;
      --pink:#ff4fa3;
      --gold:#f5c86b;
      --blue:#40a2ff;
      --green:#22c55e;
      --danger:#ef4444;
      --shadow: 0 16px 50px rgba(0,0,0,.35);
      --radius: 16px;
      --radius2: 22px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";

      --gStep: 80px;
      --gBold: 400px;
      --gOffX: 0px;
      --gOffY: 0px;

      /* Room grid (inside room box) */
      --roomStepPx: 80px;
      --roomMajorPx: 400px;
    }

    /* Softer ‚Äúeggshell paper‚Äù light mode */
    body[data-theme="light"]{
      --bg:#fbf4e6;
      --panel:#fffaf0;
      --panel2:#f5ecd9;
      --stroke: rgba(17,24,39,.16);
      --stroke2: rgba(17,24,39,.10);
      --text: rgba(17,24,39,.92);
      --muted: rgba(17,24,39,.68);
      --muted2: rgba(17,24,39,.52);
      --shadow: 0 18px 56px rgba(17,24,39,.14);
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family:var(--font);
      background:var(--bg);
      color:var(--text);
      overflow:hidden;
    }

    .app{ position:fixed; inset:0; display:flex; flex-direction:column; min-height:0; }

    /* --- Topbar --- */
    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:12px 14px;
      border-bottom:1px solid var(--stroke2);
      background: linear-gradient(90deg, rgba(139,92,246,.18), rgba(255,79,163,.10), rgba(0,0,0,0));
      flex:0 0 auto;
      gap:12px;
      min-width:0;
    }

    body[data-theme="light"] .topbar{
      background: linear-gradient(90deg, rgba(139,92,246,.10), rgba(255,79,163,.06), rgba(255,255,255,0));
    }

    .brand{ display:flex; align-items:center; gap:10px; min-width:0; }

    .brandBadge{
      width:34px;
      height:34px;
      border-radius:14px;
      display:grid;
      place-items:center;
      background: radial-gradient(circle at 20% 20%, rgba(139,92,246,1), rgba(255,79,163,.85));
      box-shadow: 0 10px 30px rgba(139,92,246,.25);
      border:1px solid rgba(255,255,255,.10);
      flex:0 0 auto;
    }

    .brandTitle{ min-width:0; }
    .brandTitle .t1{ font-weight:1000; letter-spacing:.08em; font-size:13px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .brandTitle .t2{ font-weight:800; color:var(--muted); font-size:12px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }

    .actions{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; min-width:0; overflow-x:visible; scrollbar-width:thin; padding-bottom:2px; }

    .pill{
      display:flex;
      gap:10px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--stroke2);
      background: rgba(255,255,255,.02);
      align-items:center;
      flex:0 0 auto;
    }

    .toggle{ display:flex; align-items:center; gap:8px; cursor:pointer; user-select:none; -webkit-user-select:none; }
    .toggle span{ font-weight:900; font-size:12px; color:var(--muted); }

    .switch{
      width:40px; height:22px; border-radius:999px; background:rgba(255,255,255,.08);
      border:1px solid var(--stroke);
      position:relative;
      flex:0 0 auto;
    }
    .switch::after{
      content:"";
      position:absolute;
      width:18px; height:18px;
      top:1px; left:1px;
      border-radius:999px;
      background:rgba(255,255,255,.75);
      transition: transform .18s ease;
    }
    .switch.on{ background:rgba(139,92,246,.26); border-color:rgba(139,92,246,.45); }
    .switch.on::after{ transform: translateX(18px); background:rgba(255,255,255,.92); }

    /* --- Buttons --- */
    .btn{
      border:1px solid var(--stroke);
      background:rgba(255,255,255,.03);
      color:var(--text);
      padding:9px 11px;
      border-radius:14px;
      cursor:pointer;
      font-weight:900;
      letter-spacing:.2px;
      display:inline-flex;
      align-items:center;
      gap:8px;
      user-select:none;
      -webkit-user-select:none;
      touch-action: manipulation;
      white-space:nowrap;
    }
    .btn:hover{ background:rgba(255,255,255,.06); }
    .btn.primary{ background:rgba(139,92,246,.18); border-color:rgba(139,92,246,.35); }
    .btn.primary:hover{ background:rgba(139,92,246,.25); }
    .btn.danger{ border-color: rgba(239,68,68,.35); background: rgba(239,68,68,.10); }

    .chip{
      border:1px solid var(--stroke);
      background:rgba(255,255,255,.02);
      color:var(--text);
      padding:8px 10px;
      border-radius:999px;
      cursor:pointer;
      font-weight:900;
      font-size:12px;
      display:inline-flex;
      gap:8px;
      align-items:center;
      user-select:none;
      -webkit-user-select:none;
      touch-action: manipulation;
    }
    .chip.on{ border-color:rgba(139,92,246,.55); background:rgba(139,92,246,.14); }

    .swatch{ width:14px; height:14px; border-radius:5px; border:1px solid rgba(255,255,255,.20); }
    body[data-theme="light"] .swatch{ border-color: rgba(17,24,39,.16); }

    /* --- Main Layout --- */
    .main{ flex:1 1 auto; display:flex; min-height:0; }

    .sidebar{
      width:360px;
      min-width:320px;
      max-width:420px;
      border-right:1px solid var(--stroke2);
      padding:14px;
      overflow:auto;
      min-height:0;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain;
      touch-action: pan-y;
      background: color-mix(in srgb, var(--panel) 88%, transparent);
    }

    /* Keep the Selected panel always visible near the top of the sidebar */
    .sidebar .selectedPanel{
      position: sticky;
      top: 12px;
      z-index: 12;
      backdrop-filter: blur(10px);
    }

    .panel{
      background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      border:1px solid var(--stroke2);
      border-radius:var(--radius);
      padding:12px;
      box-shadow: 0 1px 0 rgba(255,255,255,.03) inset;
      margin-bottom:12px;
    }

    body[data-theme="light"] .panel{
      background: linear-gradient(180deg, rgba(17,24,39,.03), rgba(17,24,39,.01));
    }

    .panelHeader{ display:flex; align-items:center; justify-content:space-between; margin-bottom:10px; }
    .panelHeader .h{ font-size:12px; text-transform:uppercase; letter-spacing:.14em; color:var(--muted); font-weight:1000; }

    label.small{ font-size:12px; color:var(--muted); display:block; margin-bottom:6px; font-weight:900; }

    input, textarea, select{
      width:100%;
      border:1px solid var(--stroke);
      background:rgba(255,255,255,.02);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      outline:none;
      font-weight:800;
      touch-action: manipulation;
    }

    textarea{ resize:vertical; min-height:76px; }

    .row{ display:flex; gap:10px; }
    .row > *{ flex:1; }
    .col{ flex:1; }

    .palette{ display:grid; grid-template-columns: 1fr; gap:10px; }
    .tile{
      border:1px solid var(--stroke);
      background:rgba(255,255,255,.02);
      border-radius:14px;
      padding:10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      cursor:pointer;
      user-select:none;
      -webkit-user-select:none;
      touch-action: manipulation;
      gap:10px;
    }
    .tile:hover{ background:rgba(255,255,255,.05); }
    .tile .name{ font-weight:1000; font-size:13px; }
    .tile .note{ font-size:12px; color:var(--muted2); margin-top:2px; }
    .tile .swatch{ width:18px; height:18px; border-radius:7px; }

    .chips{ display:flex; gap:8px; flex-wrap:wrap; }
    .footerNote{ color:var(--muted2); font-size:12px; line-height:1.35; white-space:pre-line; }

    .kbd{ font-weight:1000; background: rgba(255,255,255,.08); border:1px solid var(--stroke2); padding:2px 6px; border-radius:8px; }

    /* --- Canvas --- */
    .canvasCard{ flex:1; min-width:0; min-height:0; position:relative; overflow:hidden; }

    .viewport{
      position:absolute;
      inset:0;
      overflow:hidden;
      touch-action:none;
      background:
        radial-gradient(1200px 800px at 20% 20%, rgba(139,92,246,.12), transparent 55%),
        radial-gradient(1000px 700px at 80% 30%, rgba(255,79,163,.10), transparent 55%),
        radial-gradient(1000px 700px at 50% 90%, rgba(64,162,255,.08), transparent 60%);
    }

    body[data-theme="light"] .viewport{
      background:
        radial-gradient(1200px 800px at 18% 22%, rgba(139,92,246,.08), transparent 55%),
        radial-gradient(1000px 700px at 78% 30%, rgba(255,79,163,.06), transparent 55%),
        radial-gradient(1000px 700px at 50% 90%, rgba(64,162,255,.06), transparent 60%);
    }

    .infiniteGrid{
      position:absolute;
      inset:0;
      pointer-events:none;
      background-image:
        linear-gradient(to right, rgba(255,255,255,.05) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(255,255,255,.05) 1px, transparent 1px),
        linear-gradient(to right, rgba(255,255,255,.11) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(255,255,255,.11) 1px, transparent 1px);
      background-size:
        var(--gStep) var(--gStep),
        var(--gStep) var(--gStep),
        var(--gBold) var(--gBold),
        var(--gBold) var(--gBold);
      background-position:
        var(--gOffX) var(--gOffY),
        var(--gOffX) var(--gOffY),
        var(--gOffX) var(--gOffY),
        var(--gOffX) var(--gOffY);
      opacity:.55;
    }

    body[data-theme="light"] .infiniteGrid{
      background-image:
        linear-gradient(to right, rgba(17,24,39,.08) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(17,24,39,.08) 1px, transparent 1px),
        linear-gradient(to right, rgba(17,24,39,.16) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(17,24,39,.16) 1px, transparent 1px);
      opacity:.28;
    }

    .stageLayer{ position:absolute; left:0; top:0; transform-origin: 0 0; }

    .room{
      position:absolute;
      left:0; top:0;
      border-radius:22px;
      border:2px solid color-mix(in srgb, var(--stroke) 80%, transparent);
      box-shadow: var(--shadow);
      overflow:hidden;
      background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.02));
    }

    body[data-theme="light"] .room{
      background: linear-gradient(180deg, rgba(17,24,39,.02), rgba(17,24,39,.00));
    }

    .room::before{
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;
      background-image:
        linear-gradient(to right, rgba(255,255,255,.07) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(255,255,255,.07) 1px, transparent 1px),
        linear-gradient(to right, rgba(255,255,255,.12) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(255,255,255,.12) 1px, transparent 1px);
      background-size: var(--roomStepPx) var(--roomStepPx), var(--roomStepPx) var(--roomStepPx), var(--roomMajorPx) var(--roomMajorPx), var(--roomMajorPx) var(--roomMajorPx);
      opacity:.16;
    }

    body[data-theme="light"] .room::before{
      background-image:
        linear-gradient(to right, rgba(17,24,39,.08) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(17,24,39,.08) 1px, transparent 1px),
        linear-gradient(to right, rgba(17,24,39,.15) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(17,24,39,.15) 1px, transparent 1px);
      opacity:.12;
    }

    .room.noGrid::before{ display:none; }

    .bgImage{ position:absolute; left:0; top:0; transform-origin: 0 0; opacity: .95; filter: saturate(1.03) contrast(1.03); pointer-events:none; }

    .item{
      position:absolute;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.16);
      box-shadow: 0 10px 24px rgba(0,0,0,.22);
      user-select:none;
      -webkit-user-select:none;
      cursor:grab;
      transform-origin:center;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:10px;
      text-align:center;
      font-weight:1000;
      letter-spacing:.2px;
      font-size:12px;
      color:rgba(255,255,255,.92);
      touch-action:none;
    }

    body[data-theme="light"] .item{
      border:1px solid rgba(17,24,39,.16);
      box-shadow: 0 12px 28px rgba(17,24,39,.14);
      color: rgba(17,24,39,.92);
    }

    .item.locked{ cursor:not-allowed; opacity:.85; }
    .item.dragging{ cursor:grabbing; }
    .item.selected{ outline:2px solid rgba(255,79,163,.75); outline-offset:2px; }

    .itemLabel{ padding: 4px 6px; border-radius:10px; background: rgba(0,0,0,.12); pointer-events:none; }
    body[data-theme="light"] .itemLabel{ background: rgba(255,255,255,.70); }

    .handle{
      position:absolute;
      width:12px; height:12px;
      border-radius:4px;
      background: rgba(255,255,255,.95);
      border:1px solid rgba(0,0,0,.2);
      box-shadow: 0 6px 14px rgba(0,0,0,.25);
      cursor:nwse-resize;
    }

    .handle.br{ right:-6px; bottom:-6px; }
    .handle.bl{ left:-6px; bottom:-6px; cursor:nesw-resize; }
    .handle.tr{ right:-6px; top:-6px; cursor:nesw-resize; }
    .handle.tl{ left:-6px; top:-6px; }

    .rotHandle{
      position:absolute;
      top:-26px;
      left:50%;
      transform: translateX(-50%);
      width:18px; height:18px;
      border-radius:999px;
      background: rgba(139,92,246,.95);
      border:1px solid rgba(0,0,0,.2);
      box-shadow: 0 10px 20px rgba(139,92,246,.35);
      cursor:grab;
    }

    .badgeDim{
      position:absolute;
      bottom:6px;
      left:50%;
      transform: translateX(-50%);
      font-size:11px;
      padding:5px 8px;
      border-radius:999px;
      background: rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.14);
      color: rgba(255,255,255,.92);
      pointer-events:none;
      white-space:nowrap;
    }

    body[data-theme="light"] .badgeDim{
      background: rgba(255,255,255,.78);
      border:1px solid rgba(17,24,39,.12);
      color: rgba(17,24,39,.92);
    }

    .item:not(.selected) .handle,
    .item:not(.selected) .rotHandle{ display:none; }

    .help{
      position:absolute;
      left:16px;
      bottom:16px;
      width:420px;
      max-width: calc(100% - 32px);
      background: rgba(15,23,51,.86);
      border:1px solid rgba(255,255,255,.12);
      border-radius: 18px;
      padding: 12px 12px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }

    body[data-theme="light"] .help{ background: rgba(255,250,240,.90); border-color: rgba(17,24,39,.12); }
    .helpHeader{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:8px; }
    .helpHeader .h{ font-weight:1000; }
    .helpBody{ color:var(--muted); font-size:12px; line-height:1.45; }

    .toast{
      position:fixed;
      top:14px;
      left:50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,.72);
      color:#fff;
      padding:10px 14px;
      border-radius: 14px;
      font-weight:1000;
      border:1px solid rgba(255,255,255,.12);
      box-shadow: 0 16px 40px rgba(0,0,0,.35);
      z-index:999;
      display:none;
      max-width: calc(100% - 32px);
    }

    body[data-theme="light"] .toast{ background: rgba(17,24,39,.86); }
    .hide{ display:none !important; }

    /* Mini HUD (prominent controls) */
    .hud{
      position:absolute;
      top:14px;
      left:14px;
      display:flex;
      gap:8px;
      align-items:center;
      padding:10px;
      border-radius: 18px;
      background: rgba(15,23,51,.68);
      border:1px solid rgba(255,255,255,.12);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      z-index:50;
      user-select:none;
      -webkit-user-select:none;
    }
    body[data-theme="light"] .hud{ background: rgba(255,250,240,.80); border-color: rgba(17,24,39,.12); }
    .hud .btnTiny{
      height:34px;
      padding: 0 10px;
      border-radius: 14px;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.02);
      cursor:pointer;
      font-weight:1000;
      color: var(--text);
      display:inline-flex;
      align-items:center;
      gap:8px;
      touch-action: manipulation;
    }
    .hud .btnTiny.on{ border-color: rgba(255,79,163,.55); background: rgba(255,79,163,.10); }
    .hud .hint{ font-size:12px; color: var(--muted2); font-weight:900; padding-left:6px; }

    /* Scale overlay */
    .scaleOverlay{ position:absolute; inset:0; pointer-events:none; z-index:60; }
    .scaleLine{ position:absolute; height:2px; background: rgba(255,79,163,.95); transform-origin: 0 50%; border-radius: 999px; box-shadow: 0 10px 20px rgba(255,79,163,.20); }
    .scaleDot{ position:absolute; width:10px; height:10px; border-radius: 999px; background: rgba(255,79,163,.95); transform: translate(-50%,-50%); }
    .scaleLabel{ position:absolute; transform: translate(-50%,-120%); padding:6px 10px; border-radius: 999px; font-size:12px; font-weight:1000; color:#fff; background: rgba(0,0,0,.65); border: 1px solid rgba(255,255,255,.12); }
    body[data-theme="light"] .scaleLabel{ background: rgba(17,24,39,.86); }

    /* Rulers */
    .rulerTop{ position:absolute; left:0; top:-28px; height:24px; width:100%; pointer-events:none; z-index:40; }
    .rulerLeft{ position:absolute; top:0; left:-34px; width:30px; height:100%; pointer-events:none; z-index:40; }
    .rulerTick{ position:absolute; background: rgba(255,255,255,.62); opacity:.9; }
    .rulerTick.minor{ background: rgba(255,255,255,.38); opacity:.75; }
    body[data-theme="light"] .rulerTick{ background: rgba(17,24,39,.50); }
    body[data-theme="light"] .rulerTick.minor{ background: rgba(17,24,39,.30); }
    .rulerLbl{ position:absolute; font-size:11px; font-weight:1000; color: rgba(255,255,255,.80); transform: translateX(-50%); }
    body[data-theme="light"] .rulerLbl{ color: rgba(17,24,39,.70); }
    .rulerLblY{ transform: translateY(50%); left:2px; }

    /* Mobile sheet */
    .fab{
      position:fixed;
      right:16px;
      bottom:16px;
      width:56px;
      height:56px;
      border-radius: 18px;
      background: rgba(139,92,246,.95);
      border:1px solid rgba(0,0,0,.2);
      box-shadow: 0 24px 60px rgba(139,92,246,.35);
      display:none;
      align-items:center;
      justify-content:center;
      font-weight:1000;
      color:#fff;
      cursor:pointer;
      z-index:900;
      user-select:none;
      -webkit-user-select:none;
      touch-action: manipulation;
    }

    .sheetBackdrop{ position:fixed; inset:0; background: rgba(0,0,0,.45); display:none; z-index:899; }

    .sheet{
      position:fixed;
      left:0;
      right:0;
      bottom:0;
      max-height: 82vh;
      background: var(--panel);
      border-top-left-radius: 22px;
      border-top-right-radius: 22px;
      border:1px solid var(--stroke2);
      box-shadow: var(--shadow);
      display:none;
      z-index:900;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain;
      touch-action: pan-y;
      padding: 14px;
    }

    body.exporting .topbar,
    body.exporting .sidebar,
    body.exporting .help,
    body.exporting .fab,
    body.exporting .sheet,
    body.exporting .sheetBackdrop,
    body.exporting .hud{ display:none !important; }

    @media (max-width: 980px){ .sidebar{ width:340px; min-width:320px; } }

    @media (max-width: 560px){
      body{ overflow:hidden; }
      .sidebar{ display:none; }
      .fab{ display:flex; }
      .actions .btn{ display:none; }
      .actions .btn.primary{ display:inline-flex; }
      .actions .pill{ display:none; }
      .hud{ top:auto; bottom: 88px; left: 12px; right: 12px; justify-content:space-between; }
      .hud .hint{ display:none; }
    }

    body.sheetOpen{ overflow:hidden; }
  </style>
</head>
<body data-theme="dark">
  <div class="app" id="app">

    <div class="topbar">
      <div class="brand">
        <div class="brandBadge" aria-label="Sleeve heart">
          <svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 21s-7.2-4.4-9.8-9.2C-.3 7.2 2.4 3.5 6.2 3.5c2 0 3.7 1 4.8 2.4 1.1-1.4 2.9-2.4 4.8-2.4 3.8 0 6.5 3.7 4 8.3C19.2 16.6 12 21 12 21z" fill="rgba(255,255,255,.92)"/>
          </svg>
        </div>
        <div class="brandTitle">
          <div class="t1">SLEEVE EVENTS</div>
          <div class="t2">Official Event Planner ‚Ä¢ Room Layout Builder</div>
        </div>
      </div>

      <div class="actions">
        <div class="pill" id="toggles">
          <div class="toggle" id="toggleTheme"><div class="switch on" id="swTheme"></div><span id="themeLabel">Dark</span></div>
          <div class="toggle" id="toggleGrid"><div class="switch on" id="swGrid"></div><span>Grid</span></div>
          <div class="toggle" id="toggleSnap"><div class="switch on" id="swSnap"></div><span>Snap</span></div>
        </div>

        <button class="btn" id="btnUndo" title="Undo (Ctrl/‚åò+Z)">Undo</button>
        <button class="btn" id="btnRedo" title="Redo (Ctrl/‚åò+Shift+Z)">Redo</button>
        <button class="btn" id="btnTools">Tools</button>
        <button class="btn" id="btnSaveLocal">Save Local</button>
        <button class="btn" id="btnLoadLocal">Load Local</button>
        <button class="btn" id="btnDownload">Download .sleeve</button>
        <button class="btn" id="btnUpload">Upload</button>
        <button class="btn" id="btnShare">Copy Link</button>
        <button class="btn" id="btnExportPNG">Export PNG</button>
        <button class="btn primary" id="btnExportPDF">Export PDF</button>
      </div>
    </div>

    <div class="main">

      <div class="canvasCard">
        <div class="viewport" id="viewport">
          <div class="infiniteGrid" id="infiniteGrid" aria-hidden="true"></div>

          <!-- Mini HUD (prominent controls) -->
          <div class="hud" id="hud">
            <button class="btnTiny" id="hudPan" title="Pan tool">‚úã Pan</button>
            <button class="btnTiny" id="hudScale" title="Set scale">üìè Scale</button>
            <button class="btnTiny" id="hudFit" title="Fit view">‚§¢ Fit</button>
            <div class="hint" id="hudHint">Drag to select/move ‚Ä¢ Arrow keys nudge ‚Ä¢ Shift+Click multi-select</div>
          </div>

          <!-- Scale overlay -->
          <div class="scaleOverlay" id="scaleOverlay" style="display:none;">
            <div class="scaleLine" id="scaleLine"></div>
            <div class="scaleDot" id="scaleDot1"></div>
            <div class="scaleDot" id="scaleDot2"></div>
            <div class="scaleLabel" id="scaleLabel"></div>
          </div>

          <div class="stageLayer" id="stageLayer">
            <img class="bgImage" id="bgImage" alt="" />
            <div class="room" id="room">
              <div class="rulerTop" id="rulerTop"></div>
              <div class="rulerLeft" id="rulerLeft"></div>
            </div>
          </div>
        </div>

        <button class="fab" id="fab">+ Add</button>

        <div class="help" id="help">
          <div class="helpHeader">
            <div class="h">Controls</div>
            <button class="btn" id="btnHelpHide" style="height:28px;padding:0 10px;font-size:12px;box-shadow:none;">Hide</button>
          </div>
          <div class="helpBody" id="helpBody">
            <div style="display:grid;gap:10px;">
              <div>
                <div style="font-weight:1000;color:var(--text);margin-bottom:4px;">Tools</div>
                <div>‚úã <b>Pan</b>: click the Pan button (or hold <span class="kbd">Space</span>) and drag.</div>
                <div>üìè <b>Scale</b>: click Scale, then click two points, enter the real feet.</div>
              </div>
              <div>
                <div style="font-weight:1000;color:var(--text);margin-bottom:4px;">Edit</div>
                <div>Select: click ‚Ä¢ Multi-select: <span class="kbd">Shift</span>+click</div>
                <div>Nudge: <span class="kbd">Arrows</span> (Shift = bigger)</div>
                <div>Duplicate: <span class="kbd">‚åò/Ctrl</span>+<span class="kbd">D</span> ‚Ä¢ Lock: <span class="kbd">L</span> ‚Ä¢ Delete: <span class="kbd">Del</span>/<span class="kbd">Backspace</span></div>
              </div>
              <div>
                <div style="font-weight:1000;color:var(--text);margin-bottom:4px;">Mobile</div>
                <div>1-finger drag = move object ‚Ä¢ 2-finger drag = pan ‚Ä¢ pinch = zoom</div>
              </div>
              <div><span id="scaleNote">Scale: 1 ft = 40 px ‚Ä¢ Grid 2ft ‚Ä¢ Snap 2ft</span></div>
            </div>
          </div>
        </div>
      </div>

      <div class="sidebar" id="sidebar">

        <div class="panel selectedPanel">
          <div class="panelHeader"><div class="h">Selected</div></div>
          <div class="panelBody">
            <div id="selEmpty" class="footerNote">Select an object to edit label, lock, color, and size.

Multi-select: Shift+click. You can nudge, move, duplicate, delete, and lock multiple items.</div>
            <div id="selPanel" class="hide">
              <label class="small">Label</label>
              <input id="selLabel" type="text" />

              <div style="height:10px"></div>
              <div class="row">
                <div class="col">
                  <label class="small">Width</label>
                  <div id="selW" class="footerNote"></div>
                </div>
                <div class="col">
                  <label class="small">Height</label>
                  <div id="selH" class="footerNote"></div>
                </div>
              </div>

              <div style="height:10px"></div>
              <div class="chips">
                <div class="chip" id="chipLock"><span class="swatch" style="background:rgba(255,255,255,.12)"></span>Lock Selected</div>
                <div class="chip" id="chipDuplicate"><span class="swatch" style="background:rgba(255,255,255,.12)"></span>Duplicate</div>
                <div class="chip" id="chipRotL"><span class="swatch" style="background:rgba(255,255,255,.12)"></span>‚ü≤ -45¬∞</div>
                <div class="chip" id="chipRotR"><span class="swatch" style="background:rgba(255,255,255,.12)"></span>‚ü≥ +45¬∞</div>
                <div class="chip" id="chipDelete" style="border-color:rgba(255,77,77,.35);"><span class="swatch" style="background:rgba(255,77,77,.65)"></span>Delete</div>
              </div>

              <div style="height:10px"></div>
              <label class="small">Color</label>
              <div class="chips" id="colorChips"></div>
            </div>
          </div>
        </div>

        <div class="panel">
          <div class="panelHeader"><div class="h">Project</div></div>
          <div class="panelBody">
            <label class="small">Event Name</label>
            <input id="eventName" type="text" placeholder="e.g., Karla & Andrew Wedding" />
            <div style="height:10px"></div>
            <label class="small">Notes</label>
            <textarea id="eventNotes" placeholder="Load-in notes, vendor cues, timeline, etc."></textarea>

            <div style="height:10px"></div>
            <div class="row">
              <div class="col">
                <label class="small">Room Size (ft)</label>
                <div class="row">
                  <input id="roomW" type="text" value="60" />
                  <input id="roomH" type="text" value="40" />
                </div>
              </div>
              <div class="col">
                <label class="small">Grid (ft)</label>
                <select id="gridStep">
                  <option value="1">1 ft</option>
                  <option value="2" selected>2 ft</option>
                  <option value="5">5 ft</option>
                </select>
              </div>
            </div>

            <div style="height:10px"></div>
            <div class="row">
              <button class="btn" id="btnApplyRoom" style="flex:1;">Apply Room</button>
              <button class="btn" id="btnFit" style="flex:1;">Fit</button>
            </div>

            <div style="height:10px"></div>
            <div class="row">
              <button class="btn" id="btnSetScale" style="flex:1;">Set Scale</button>
              <button class="btn" id="btnClear" style="flex:1;">Clear</button>
            </div>

            <div style="height:10px"></div>
            <label class="small">Background</label>
            <div class="footerNote" style="margin:-2px 0 8px;">Upload PNG/JPG or PDF (imports page 1). Toggle Lock BG to move it.</div>
            <div class="row">
              <button class="btn" id="btnBgUpload" style="flex:1;">Upload</button>
              <button class="btn" id="btnBgFit" style="flex:1;">Fit</button>
            </div>
            <div style="height:8px"></div>
            <div class="chips">
              <div class="chip on" id="chipBgLock"><span class="swatch" style="background:rgba(255,255,255,.12)"></span>Lock BG</div>
              <div class="chip on" id="chipShowGrid"><span class="swatch" style="background:rgba(255,255,255,.12)"></span>Show Grid</div>
              <div class="chip on" id="chipSnap"><span class="swatch" style="background:rgba(255,255,255,.12)"></span>Snap</div>
            </div>
          </div>
        </div>

        <div class="panel">
          <div class="panelHeader"><div class="h">Objects</div></div>
          <div class="panelBody">
            <div class="palette" id="palette"></div>
            <div style="height:12px"></div>
            <div class="footerNote">Tip: place, then <span class="kbd">‚åò/Ctrl</span>+<span class="kbd">D</span> duplicates fast. Multi-select with <span class="kbd">Shift</span>+click. Lock with <span class="kbd">L</span>.</div>
          </div>
        </div>

        <div class="panel">
          <div class="panelHeader"><div class="h">Gear Summary</div></div>
          <div class="panelBody">
            <div id="gear" class="footerNote"></div>
          </div>
        </div>

      </div>

    </div>

    <div class="sheetBackdrop" id="sheetBackdrop"></div>
    <div class="sheet" id="sheet">
      <div style="display:flex;gap:8px;justify-content:space-between;align-items:center;margin-bottom:10px;">
        <div style="font-weight:1000;letter-spacing:.02em;">Tools</div>
        <button class="btn" id="btnSheetClose" style="height:30px;padding:0 12px;font-size:12px;box-shadow:none;">Close</button>
      </div>

      <div class="panel" style="box-shadow:none;">
        <div class="panelHeader"><div class="h">Quick Actions</div></div>
        <div class="panelBody">
          <div class="row">
            <button class="btn" id="mUndo" style="flex:1;">Undo</button>
            <button class="btn" id="mRedo" style="flex:1;">Redo</button>
          </div>
          <div style="height:8px"></div>
          <div class="row">
            <button class="btn" id="mSetScale" style="flex:1;">Set Scale</button>
            <button class="btn" id="mFit" style="flex:1;">Fit</button>
          </div>
          <div style="height:8px"></div>
          <div class="row">
            <button class="btn" id="mBgUpload" style="flex:1;">BG Upload</button>
            <button class="btn" id="mBgFit" style="flex:1;">BG Fit</button>
          </div>
          <div style="height:8px"></div>
          <div class="row">
            <button class="btn" id="mDemoWedding" style="flex:1;">Demo Wedding</button>
            <button class="btn" id="mDemoMitzvah" style="flex:1;">Demo Mitzvah</button>
          </div>
        </div>
      </div>

      <div style="height:10px"></div>
      <div class="panel" style="box-shadow:none;">
        <div class="panelHeader"><div class="h">Add Objects</div></div>
        <div class="panelBody"><div class="palette" id="paletteMobile"></div></div>
      </div>

      <div style="height:10px"></div>
      <div class="panel" style="box-shadow:none;">
        <div class="panelHeader"><div class="h">Exports</div></div>
        <div class="panelBody">
          <div class="row">
            <button class="btn" id="mExportPNG" style="flex:1;">Export PNG</button>
            <button class="btn primary" id="mExportPDF" style="flex:1;">Export PDF</button>
          </div>
          <div style="height:8px"></div>
          <div class="row">
            <button class="btn" id="mShare" style="flex:1;">Copy Link</button>
            <button class="btn" id="mDownload" style="flex:1;">Download .sleeve</button>
          </div>
          <div style="height:8px"></div>
          <div class="row">
            <button class="btn" id="mSaveLocal" style="flex:1;">Save Local</button>
            <button class="btn" id="mLoadLocal" style="flex:1;">Load Local</button>
          </div>
          <div style="height:8px"></div>
          <div class="row">
            <button class="btn" id="mUpload" style="flex:1;">Upload</button>
            <button class="btn" id="mClear" style="flex:1;">Clear</button>
          </div>
        </div>
      </div>

      <div style="height:12px"></div>
      <div class="footerNote">Exports include branding footer: SleeveEvents.com ‚Ä¢ stephen@sleeveevents.com</div>
    </div>

    <input id="fileUpload" type="file" accept=".sleeve,application/json" class="hide" />
    <input id="bgUpload" type="file" accept="image/png,image/jpeg,application/pdf" class="hide" />

    <div class="toast" id="toast"></div>
  </div>

  <script>
    /* =========================================================
       STATE
       ========================================================= */
    const State = {
      version: 1,
      eventName: '',
      eventNotes: '',
      theme: 'dark',
      roomFt: { w: 60, h: 40 },
      pxPerFt: 40,
      gridOn: true,
      snapOn: true,
      gridStepFt: 2,
      snapStepFt: 2,
      bg: { src: '', locked: true, fitMode: 'contain', x: 0, y: 0, scale: 1 },
      view: { zoom: 1, panX: 0, panY: 0 },
      items: [],
      selected: new Set(),
      mode: 'idle',
      pointer: { id: null },
      drag: null,
      scaleTool: { step: 0, p1: null, p2: null, hover: null },
      ui: {
        panTool: false,
      },
      gesture: {
        pointers: new Map(),
        active: false,
        startDist: 0,
        startZoom: 1,
        startPanX: 0,
        startPanY: 0,
        startMid: null,
      }
    };

    const ExportBrand = {
      site: 'SleeveEvents.com',
      email: 'stephen@sleeveevents.com',
      tagline: 'Every Moment, With Love & Precision'
    };

    /* =========================================================
       HISTORY (UNDO/REDO)
       ========================================================= */
    const History = {
      past: [],
      future: [],
      max: 80,
      _frozen: false,

      snapshot(){
        return {
          eventName: State.eventName,
          eventNotes: State.eventNotes,
          theme: State.theme,
          roomFt: { ...State.roomFt },
          pxPerFt: State.pxPerFt,
          gridOn: State.gridOn,
          snapOn: State.snapOn,
          gridStepFt: State.gridStepFt,
          snapStepFt: State.snapStepFt,
          bg: JSON.parse(JSON.stringify(State.bg)),
          view: { ...State.view },
          items: JSON.parse(JSON.stringify(State.items)),
          selected: [...State.selected],
        };
      },

      restore(snap){
        if (!snap) return;
        this._frozen = true;
        State.eventName = snap.eventName || '';
        State.eventNotes = snap.eventNotes || '';
        State.theme = snap.theme || 'dark';
        State.roomFt = snap.roomFt || { w:60, h:40 };
        State.pxPerFt = snap.pxPerFt || 40;
        State.gridOn = (snap.gridOn !== undefined) ? snap.gridOn : true;
        State.snapOn = (snap.snapOn !== undefined) ? snap.snapOn : true;
        State.gridStepFt = snap.gridStepFt || 2;
        State.snapStepFt = snap.snapStepFt || State.gridStepFt;
        State.bg = snap.bg || State.bg;
        State.view = snap.view || State.view;
        State.items = Array.isArray(snap.items) ? snap.items : [];
        State.selected = new Set(Array.isArray(snap.selected) ? snap.selected : []);

        UI.eventName.value = State.eventName;
        UI.eventNotes.value = State.eventNotes;
        UI.roomW.value = State.roomFt.w;
        UI.roomH.value = State.roomFt.h;
        UI.gridStep.value = String(State.gridStepFt);

        applyTheme();
        applyRoom();
        applyView();
        renderBg();
        renderGrid();
        renderItems();
        updateScaleNote();
        updateUndoRedoButtons();
        this._frozen = false;
      },

      push(reason){
        if (this._frozen) return;
        const snap = this.snapshot();
        const last = this.past[this.past.length - 1];
        if (last && JSON.stringify(last) === JSON.stringify(snap)) return;
        this.past.push(snap);
        if (this.past.length > this.max) this.past.shift();
        this.future.length = 0;
        updateUndoRedoButtons();
      },

      undo(){
        if (!this.past.length) return;
        const cur = this.snapshot();
        const prev = this.past.pop();
        this.future.push(cur);
        this.restore(prev);
        toast('Undo');
      },

      redo(){
        if (!this.future.length) return;
        const cur = this.snapshot();
        const next = this.future.pop();
        this.past.push(cur);
        this.restore(next);
        toast('Redo');
      }
    };

    function updateUndoRedoButtons(){
      UI.btnUndo.disabled = History.past.length === 0;
      UI.btnRedo.disabled = History.future.length === 0;
      UI.mUndo.disabled = History.past.length === 0;
      UI.mRedo.disabled = History.future.length === 0;
    }

    /* =========================================================
       UTILITIES
       ========================================================= */
    const uid = () => Math.random().toString(36).slice(2, 10);
    const clamp = (v,min,max)=>Math.max(min, Math.min(max, v));
    const roundTo = (v, step)=>Math.round(v/step)*step;
    const dist = (a,b)=>Math.hypot(a.x-b.x, a.y-b.y);
    const safeFile = (name)=> (name||'').replace(/[^a-z0-9\-\_]+/gi,'_').slice(0,80);

    function normalizeAngle(deg){ let a = deg % 360; if (a < 0) a += 360; return Math.round(a * 1000) / 1000; }

    function ftInFromPx(px){
      const ft = px / State.pxPerFt;
      const totalIn = ft * 12;
      const rIn = Math.round(totalIn);
      const oFt = Math.floor(rIn / 12);
      const oIn = rIn % 12;
      return { ft: oFt, inch: oIn, rawFt: ft };
    }

    function fmtFtIn(px){
      if (!State.pxPerFt || State.pxPerFt <= 0) return '‚Äî';
      const d = ftInFromPx(px);
      return `${d.ft}' ${d.inch}\"`;
    }

    function snapPx(px){
      if (!State.snapOn || !State.pxPerFt) return px;
      const stepPx = State.snapStepFt * State.pxPerFt;
      return roundTo(px, stepPx);
    }

    function toast(msg){
      const el = UI.toast;
      el.textContent = msg;
      el.style.display = 'block';
      clearTimeout(toast._t);
      toast._t = setTimeout(()=> el.style.display='none', 1800);
    }

    function deepCopy(obj){ return JSON.parse(JSON.stringify(obj)); }

    function encodeProjectToURL(project){
      const json = JSON.stringify(project);
      const b64 = btoa(unescape(encodeURIComponent(json)));
      return `${location.origin}${location.pathname}#p=${b64}`;
    }

    function decodeProjectFromURL(){
      const h = location.hash || '';
      const m = h.match(/#p=([A-Za-z0-9+/=]+)/);
      if (!m) return null;
      try{
        const json = decodeURIComponent(escape(atob(m[1])));
        return JSON.parse(json);
      } catch(_){
        return null;
      }
    }

    function isEditableTarget(el){
      return !!(el && (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.isContentEditable));
    }

    /* =========================================================
       POINTER CAPTURE (SAFE)
       ========================================================= */
    const PointerCapture = {
      el: null,
      pid: null,
      safeCapture(pointerId, el){
        try{
          if (pointerId === undefined || pointerId === null) return false;
          if (!el || !el.isConnected) return false;
          if (typeof el.setPointerCapture !== 'function') return false;

          if (typeof el.hasPointerCapture === 'function'){
            if (!el.hasPointerCapture(pointerId)) el.setPointerCapture(pointerId);
          } else {
            el.setPointerCapture(pointerId);
          }

          this.el = el;
          this.pid = pointerId;
          return true;
        } catch(_){
          return false;
        }
      },
      reset(pointerId){
        try{
          if (this.pid !== pointerId) return;
          const el = this.el;
          if (!el || typeof el.releasePointerCapture !== 'function') return;

          if (typeof el.hasPointerCapture === 'function'){
            if (el.hasPointerCapture(pointerId)) el.releasePointerCapture(pointerId);
          } else {
            el.releasePointerCapture(pointerId);
          }
        } catch(_){
          // ignore
        } finally {
          if (this.pid === pointerId){ this.el = null; this.pid = null; }
        }
      }
    };

    /* =========================================================
       OBJECT DEFINITIONS
       ========================================================= */
    const COLORS = [
      { key:'brand', name:'Purple', hex:'#8b5cf6' },
      { key:'pink',  name:'Pink',   hex:'#ff4fa3' },
      { key:'black', name:'Black',  hex:'#0b1020' },
      { key:'white', name:'White',  hex:'#ffffff' },
      { key:'gold',  name:'Gold',   hex:'#f5c86b' },
      { key:'blue',  name:'Blue',   hex:'#40a2ff' },
      { key:'green', name:'Green',  hex:'#22c55e' },
    ];

    const ObjectDefs = [
      { type:'dj_booth',     name:'DJ Booth',        note:'6ft',   wFt:6,  hFt:3,  color:'brand' },
      { type:'speaker_pair', name:'Speaker Pair',    note:'L/R',   wFt:2.5,hFt:2,  color:'blue', meta:{pair:true} },
      { type:'dance_floor',  name:'Dance Floor',     note:'12√ó12', wFt:12, hFt:12, color:'gold' },
      { type:'photo_booth',  name:'Photobooth',      note:'8√ó8',   wFt:8,  hFt:8,  color:'pink' },
      { type:'round_48',     name:'Round Table',     note:'48\"',  wFt:4,  hFt:4,  color:'green', shape:'circle' },
      { type:'round_60',     name:'Round Table',     note:'60\"',  wFt:5,  hFt:5,  color:'green', shape:'circle' },
      { type:'round_72',     name:'Round Table',     note:'72\"',  wFt:6,  hFt:6,  color:'green', shape:'circle' },
      { type:'rect_6',       name:'Rect Table',      note:'6ft',   wFt:6,  hFt:2.5,color:'green' },
      { type:'bar',          name:'Bar',             note:'',      wFt:12, hFt:3,  color:'blue' },
      { type:'stage',        name:'Stage',           note:'',      wFt:16, hFt:8,  color:'brand' },
      { type:'cocktail',     name:'Cocktail Table',  note:'High',  wFt:2.5,hFt:2.5,color:'green', shape:'circle' },
      { type:'sweetheart',   name:'Sweetheart',      note:'B&G',   wFt:6,  hFt:2.5,color:'pink' },
      { type:'head_table',   name:'Head Table',      note:'Long',  wFt:18, hFt:3,  color:'pink' },
      { type:'arch',         name:'Ceremony Arch',   note:'',      wFt:10, hFt:2,  color:'gold' },
      { type:'uplight',      name:'Uplight',         note:'',      wFt:0.5,hFt:0.5,color:'brand', shape:'circle' },
      { type:'moving_head',  name:'Moving Head',     note:'',      wFt:1,  hFt:1,  color:'brand', shape:'circle' },
      { type:'truss',        name:'Truss',           note:'10ft',  wFt:10, hFt:1,  color:'black' },
      { type:'custom_rect',  name:'Custom Rect',     note:'',      wFt:6,  hFt:4,  color:'brand' },
    ];

    const defByType = (t)=>ObjectDefs.find(o=>o.type===t);

    const colorHex = (key)=>{
      const c = COLORS.find(c=>c.key===key);
      return c ? c.hex : '#8b5cf6';
    };

    // Solid (high-opacity) colors for objects
// Goal: readable, ‚Äúreal‚Äù blocks on top of background images + grid.
const computeItemBg = (it)=>{
  const hex = colorHex(it.color || 'brand');
  // Much more solid than before (was ~0.32 / ~0.22)
  const alpha = (State.theme === 'dark') ? 0.86 : 0.80;
  return hex + Math.round(alpha*255).toString(16).padStart(2,'0');
};

// Canvas helper: convert #RRGGBB (+ optional alpha 0..1) to rgba()
function hexToRgba(hex, a=1){
  const h = String(hex || '').replace('#','').trim();
  const r = parseInt(h.slice(0,2), 16) || 0;
  const g = parseInt(h.slice(2,4), 16) || 0;
  const b = parseInt(h.slice(4,6), 16) || 0;
  const aa = clamp(a, 0, 1);
  return `rgba(${r},${g},${b},${aa})`;
}

    /* =========================================================
       UI REFERENCES
       ========================================================= */
    const UI = {
      // Topbar + toggles
      toggleTheme: document.getElementById('toggleTheme'),
      toggleGrid: document.getElementById('toggleGrid'),
      toggleSnap: document.getElementById('toggleSnap'),
      swTheme: document.getElementById('swTheme'),
      swGrid: document.getElementById('swGrid'),
      swSnap: document.getElementById('swSnap'),
      themeLabel: document.getElementById('themeLabel'),

      btnUndo: document.getElementById('btnUndo'),
      btnRedo: document.getElementById('btnRedo'),
      btnTools: document.getElementById('btnTools'),
      btnSaveLocal: document.getElementById('btnSaveLocal'),
      btnLoadLocal: document.getElementById('btnLoadLocal'),
      btnDownload: document.getElementById('btnDownload'),
      btnUpload: document.getElementById('btnUpload'),
      btnShare: document.getElementById('btnShare'),
      btnExportPNG: document.getElementById('btnExportPNG'),
      btnExportPDF: document.getElementById('btnExportPDF'),

      // Viewport + stage
      viewport: document.getElementById('viewport'),
      infiniteGrid: document.getElementById('infiniteGrid'),
      stageLayer: document.getElementById('stageLayer'),
      room: document.getElementById('room'),
      bgImage: document.getElementById('bgImage'),

      // HUD
      hud: document.getElementById('hud'),
      hudPan: document.getElementById('hudPan'),
      hudScale: document.getElementById('hudScale'),
      hudFit: document.getElementById('hudFit'),

      // Scale overlay
      scaleOverlay: document.getElementById('scaleOverlay'),
      scaleLine: document.getElementById('scaleLine'),
      scaleDot1: document.getElementById('scaleDot1'),
      scaleDot2: document.getElementById('scaleDot2'),
      scaleLabelEl: document.getElementById('scaleLabel'),

      // Rulers
      rulerTop: document.getElementById('rulerTop'),
      rulerLeft: document.getElementById('rulerLeft'),

      // Help
      help: document.getElementById('help'),
      btnHelpHide: document.getElementById('btnHelpHide'),
      helpBody: document.getElementById('helpBody'),
      scaleNote: document.getElementById('scaleNote'),

      // Sidebar fields
      sidebar: document.getElementById('sidebar'),
      eventName: document.getElementById('eventName'),
      eventNotes: document.getElementById('eventNotes'),
      roomW: document.getElementById('roomW'),
      roomH: document.getElementById('roomH'),
      gridStep: document.getElementById('gridStep'),
      btnApplyRoom: document.getElementById('btnApplyRoom'),
      btnFit: document.getElementById('btnFit'),
      btnSetScale: document.getElementById('btnSetScale'),
      btnClear: document.getElementById('btnClear'),
      btnBgUpload: document.getElementById('btnBgUpload'),
      btnBgFit: document.getElementById('btnBgFit'),
      chipBgLock: document.getElementById('chipBgLock'),
      chipShowGrid: document.getElementById('chipShowGrid'),
      chipSnap: document.getElementById('chipSnap'),
      palette: document.getElementById('palette'),
      gear: document.getElementById('gear'),

      // Selected panel
      selEmpty: document.getElementById('selEmpty'),
      selPanel: document.getElementById('selPanel'),
      selLabel: document.getElementById('selLabel'),
      selW: document.getElementById('selW'),
      selH: document.getElementById('selH'),
      chipLock: document.getElementById('chipLock'),
      chipDuplicate: document.getElementById('chipDuplicate'),
      chipRotL: document.getElementById('chipRotL'),
      chipRotR: document.getElementById('chipRotR'),
      chipDelete: document.getElementById('chipDelete'),
      colorChips: document.getElementById('colorChips'),

      // Mobile sheet
      fab: document.getElementById('fab'),
      sheetBackdrop: document.getElementById('sheetBackdrop'),
      sheet: document.getElementById('sheet'),
      btnSheetClose: document.getElementById('btnSheetClose'),
      paletteMobile: document.getElementById('paletteMobile'),
      mUndo: document.getElementById('mUndo'),
      mRedo: document.getElementById('mRedo'),
      mSetScale: document.getElementById('mSetScale'),
      mFit: document.getElementById('mFit'),
      mBgUpload: document.getElementById('mBgUpload'),
      mBgFit: document.getElementById('mBgFit'),
      mDemoWedding: document.getElementById('mDemoWedding'),
      mDemoMitzvah: document.getElementById('mDemoMitzvah'),
      mExportPNG: document.getElementById('mExportPNG'),
      mExportPDF: document.getElementById('mExportPDF'),
      mShare: document.getElementById('mShare'),
      mDownload: document.getElementById('mDownload'),
      mSaveLocal: document.getElementById('mSaveLocal'),
      mLoadLocal: document.getElementById('mLoadLocal'),
      mUpload: document.getElementById('mUpload'),
      mClear: document.getElementById('mClear'),

      // File inputs
      fileUpload: document.getElementById('fileUpload'),
      bgUpload: document.getElementById('bgUpload'),

      // Toast
      toast: document.getElementById('toast'),
    };

    /* =========================================================
       RENDERING (STABLE DOM)
       ========================================================= */
    const ItemEls = new Map(); // id -> {root, label, badge}

    function ensureItemEl(it){
      let rec = ItemEls.get(it.id);
      if (rec) return rec;

      const el = document.createElement('div');
      el.className = 'item';
      el.dataset.id = it.id;

      const label = document.createElement('div');
      label.className = 'itemLabel';
      el.appendChild(label);

      const br = document.createElement('div'); br.className='handle br';
      const bl = document.createElement('div'); bl.className='handle bl';
      const tr = document.createElement('div'); tr.className='handle tr';
      const tl = document.createElement('div'); tl.className='handle tl';
      const rot = document.createElement('div'); rot.className='rotHandle';
      const badge = document.createElement('div'); badge.className='badgeDim';

      el.appendChild(br); el.appendChild(bl); el.appendChild(tr); el.appendChild(tl);
      el.appendChild(rot);
      el.appendChild(badge);

      el.addEventListener('pointerdown', (e)=>onItemPointerDown(e, it.id));
      br.addEventListener('pointerdown', (e)=>onHandleDown(e, it.id, 'br'));
      bl.addEventListener('pointerdown', (e)=>onHandleDown(e, it.id, 'bl'));
      tr.addEventListener('pointerdown', (e)=>onHandleDown(e, it.id, 'tr'));
      tl.addEventListener('pointerdown', (e)=>onHandleDown(e, it.id, 'tl'));
      rot.addEventListener('pointerdown', (e)=>onRotateDown(e, it.id));

      UI.room.appendChild(el);
      rec = { root: el, label, badge };
      ItemEls.set(it.id, rec);
      return rec;
    }

    function removeMissingItemEls(){
      const alive = new Set(State.items.map(i=>i.id));
      for (const [id, rec] of ItemEls.entries()){
        if (!alive.has(id)){
          rec.root.remove();
          ItemEls.delete(id);
        }
      }
    }

    function updateItemEl(it){
      const rec = ensureItemEl(it);
      const el = rec.root;

      el.style.left = it.x + 'px';
      el.style.top  = it.y + 'px';
      el.style.width = it.w + 'px';
      el.style.height= it.h + 'px';
      el.style.transform = `rotate(${it.rot}deg)`;
      el.style.background = computeItemBg(it);

      const d = defByType(it.type);
      el.style.borderRadius = (d?.shape === 'circle') ? '999px' : '12px';

      el.classList.toggle('selected', State.selected.has(it.id));
      el.classList.toggle('locked', !!it.locked);

      rec.label.textContent = it.label || (d?.name || 'Object');
      rec.badge.textContent = `${fmtFtIn(it.w)} √ó ${fmtFtIn(it.h)}`;
    }

    function renderItems(){
      removeMissingItemEls();
      for (const it of State.items) updateItemEl(it);
      updateSelectedPanel();
      updateGear();
    }

    /* =========================================================
       GRID + VIEW (INFINITE GRID FEEL)
       ========================================================= */
    function updateInfiniteGrid(){
      if (!UI.infiniteGrid) return;
      if (!State.gridOn){ UI.infiniteGrid.style.display = 'none'; return; }

      const stepWorld = Math.max(2, State.gridStepFt * State.pxPerFt);
      const boldWorld = stepWorld * 5;

      const stepScreen = stepWorld * State.view.zoom;
      const boldScreen = boldWorld * State.view.zoom;

      const mod = (n, m) => ((n % m) + m) % m;
      const offX = -mod(State.view.panX, stepScreen);
      const offY = -mod(State.view.panY, stepScreen);

      UI.infiniteGrid.style.setProperty('--gStep', `${stepScreen}px`);
      UI.infiniteGrid.style.setProperty('--gBold', `${boldScreen}px`);
      UI.infiniteGrid.style.setProperty('--gOffX', `${offX}px`);
      UI.infiniteGrid.style.setProperty('--gOffY', `${offY}px`);
      UI.infiniteGrid.style.display = 'block';
    }

    function applyTheme(){
      document.body.setAttribute('data-theme', State.theme);
      const on = State.theme === 'dark';
      UI.swTheme.classList.toggle('on', on);
      UI.themeLabel.textContent = on ? 'Dark' : 'Light';
    }

    function renderGrid(){
      UI.swGrid.classList.toggle('on', State.gridOn);
      UI.swSnap.classList.toggle('on', State.snapOn);
      UI.chipShowGrid.classList.toggle('on', State.gridOn);
      UI.chipSnap.classList.toggle('on', State.snapOn);

      // Room grid hash marks: minor = gridStepFt, major = 5ft
      const stepPx = Math.max(2, State.gridStepFt * State.pxPerFt);
      const majorPx = Math.max(stepPx, 5 * State.pxPerFt);
      UI.room.style.setProperty('--roomStepPx', stepPx + 'px');
      UI.room.style.setProperty('--roomMajorPx', majorPx + 'px');

      UI.room.classList.toggle('noGrid', !State.gridOn);
      updateInfiniteGrid();
    }

    function buildRulers(){
      UI.rulerTop.innerHTML = '';
      UI.rulerLeft.innerHTML = '';

      const roomWpx = State.roomFt.w * State.pxPerFt;
      const roomHpx = State.roomFt.h * State.pxPerFt;

      const tickFt = 5;
      const minorFt = 1;

      // Top ruler
      for (let ft=0; ft<=State.roomFt.w; ft+=minorFt){
        const x = ft * State.pxPerFt;
        const isMajor = (ft % tickFt === 0);
        const t = document.createElement('div');
        t.className = 'rulerTick' + (isMajor ? '' : ' minor');
        t.style.left = x + 'px';
        t.style.bottom = '0px';
        t.style.width = '1px';
        t.style.height = isMajor ? '12px' : '8px';
        UI.rulerTop.appendChild(t);

        if (isMajor && ft % 10 === 0){
          const lbl = document.createElement('div');
          lbl.className = 'rulerLbl';
          lbl.style.left = x + 'px';
          lbl.style.top = '0px';
          lbl.textContent = `${ft}ft`;
          UI.rulerTop.appendChild(lbl);
        }
      }

      // Left ruler
      for (let ft=0; ft<=State.roomFt.h; ft+=minorFt){
        const y = ft * State.pxPerFt;
        const isMajor = (ft % tickFt === 0);
        const t = document.createElement('div');
        t.className = 'rulerTick' + (isMajor ? '' : ' minor');
        t.style.top = y + 'px';
        t.style.right = '0px';
        t.style.height = '1px';
        t.style.width = isMajor ? '12px' : '8px';
        UI.rulerLeft.appendChild(t);

        if (isMajor && ft % 10 === 0){
          const lbl = document.createElement('div');
          lbl.className = 'rulerLbl rulerLblY';
          lbl.style.top = y + 'px';
          lbl.textContent = `${ft}`;
          UI.rulerLeft.appendChild(lbl);
        }
      }

      // Keep rulers visible even if small
      UI.rulerTop.style.width = roomWpx + 'px';
      UI.rulerLeft.style.height = roomHpx + 'px';
    }

    function applyRoom(){
      const w = clamp(parseFloat(UI.roomW.value)||State.roomFt.w, 5, 400);
      const h = clamp(parseFloat(UI.roomH.value)||State.roomFt.h, 5, 400);
      State.roomFt.w = w; State.roomFt.h = h;

      const pxW = w * State.pxPerFt;
      const pxH = h * State.pxPerFt;

      UI.room.style.width = pxW + 'px';
      UI.room.style.height = pxH + 'px';
      UI.stageLayer.style.width = pxW + 'px';
      UI.stageLayer.style.height = pxH + 'px';

      buildRulers();
      renderBg();
      renderGrid();
      renderItems();
      updateScaleNote();
    }

    function applyView(){
      UI.stageLayer.style.transform = `translate(${State.view.panX}px, ${State.view.panY}px) scale(${State.view.zoom})`;
      updateInfiniteGrid();
    }

    function updateScaleNote(){
      UI.scaleNote.textContent = `Scale: 1 ft = ${Math.round(State.pxPerFt)} px ‚Ä¢ Grid ${State.gridStepFt}ft ‚Ä¢ Snap ${State.snapStepFt}ft`;
    }

    function screenToRoomPoint(clientX, clientY){
      // Use State.view directly (more reliable than computedStyle matrix across browsers)
      const rect = UI.viewport.getBoundingClientRect();
      const sx = clientX - rect.left;
      const sy = clientY - rect.top;
      return {
        x: (sx - State.view.panX) / State.view.zoom,
        y: (sy - State.view.panY) / State.view.zoom,
      };
    }

    function screenPointFromClient(clientX, clientY){
      const rect = UI.viewport.getBoundingClientRect();
      return { x: clientX - rect.left, y: clientY - rect.top, rect };
    }

    function zoomAt(clientX, clientY, newZoom){
      const { x: sx, y: sy } = screenPointFromClient(clientX, clientY);
      const oldZoom = State.view.zoom;
      const z = clamp(newZoom, 0.25, 4);
      if (z === oldZoom) return;

      const wx = (sx - State.view.panX) / oldZoom;
      const wy = (sy - State.view.panY) / oldZoom;

      State.view.zoom = z;
      State.view.panX = sx - wx * z;
      State.view.panY = sy - wy * z;

      applyView();
    }

    /* =========================================================
       BACKGROUND
       ========================================================= */
    function renderBg(){
      if (!State.bg.src){ UI.bgImage.style.display = 'none'; return; }
      UI.bgImage.style.display = 'block';
      UI.bgImage.src = State.bg.src;
      UI.bgImage.style.transform = `translate(${State.bg.x}px, ${State.bg.y}px) scale(${State.bg.scale})`;
      UI.chipBgLock.classList.toggle('on', State.bg.locked);
    }

    function fileToDataURL(file){
      return new Promise((res,rej)=>{
        const r = new FileReader();
        r.onload = ()=>res(r.result);
        r.onerror = rej;
        r.readAsDataURL(file);
      });
    }

    const PdfImport = {
      loaded:false,
      loading:false,
      loadPromise:null,
      async ensureLoaded(){
        if (this.loaded) return true;
        if (this.loading) return this.loadPromise;
        this.loading = true;
        this.loadPromise = (async ()=>{
          const scriptUrl = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.min.js';
          const workerUrl = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.worker.min.js';

          await new Promise((resolve, reject)=>{
            const s = document.createElement('script');
            s.src = scriptUrl;
            s.async = true;
            s.onload = resolve;
            s.onerror = reject;
            document.head.appendChild(s);
          });

          if (!window.pdfjsLib) throw new Error('PDF.js failed to load');
          window.pdfjsLib.GlobalWorkerOptions.workerSrc = workerUrl;
          this.loaded = true;
          return true;
        })().finally(()=>{ this.loading = false; });

        return this.loadPromise;
      },

      async pdfFileToPngDataURL(file, opts={}){
        const maxSide = opts.maxSide || 2600;
        const qualityScale = opts.qualityScale || 2;

        await this.ensureLoaded();

        const buf = await file.arrayBuffer();
        const doc = await window.pdfjsLib.getDocument({ data: buf }).promise;
        const page = await doc.getPage(1);

        let viewport = page.getViewport({ scale: qualityScale });
        const maxDim = Math.max(viewport.width, viewport.height);
        if (maxDim > maxSide){
          const down = maxSide / maxDim;
          viewport = page.getViewport({ scale: qualityScale * down });
        }

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        canvas.width = Math.max(1, Math.floor(viewport.width));
        canvas.height = Math.max(1, Math.floor(viewport.height));

        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0,0,canvas.width,canvas.height);

        await page.render({ canvasContext: ctx, viewport }).promise;
        return canvas.toDataURL('image/png');
      }
    };

    function bgFit(){
      if (!State.bg.src){ toast('No background'); return; }
      const img = UI.bgImage;
      const rw = State.roomFt.w * State.pxPerFt;
      const rh = State.roomFt.h * State.pxPerFt;
      const iw = img.naturalWidth || rw;
      const ih = img.naturalHeight || rh;
      const s = Math.min(rw/iw, rh/ih);
      State.bg.scale = s;
      State.bg.x = (rw - iw*s)/2;
      State.bg.y = (rh - ih*s)/2;
      renderBg();
      History.push('bg-fit');
      toast('Background fit');
    }

    UI.bgUpload.addEventListener('change', async (e)=>{
      const f = e.target.files && e.target.files[0];
      if (!f) return;

      try{
        const isPdf = (f.type === 'application/pdf') || /\.pdf$/i.test(f.name);

        History.push('before-bg-upload');

        if (isPdf){
          toast('Importing PDF (page 1)‚Ä¶');
          const data = await PdfImport.pdfFileToPngDataURL(f, { maxSide: 3000, qualityScale: 2.2 });
          State.bg.src = data;
          UI.bgImage.onload = ()=>{ bgFit(); };
          renderBg();
          toast('PDF imported');
        } else {
          const data = await fileToDataURL(f);
          State.bg.src = data;
          UI.bgImage.onload = ()=>{ bgFit(); };
          renderBg();
          toast('Image uploaded');
        }
      } catch(err){
        console.error(err);
        alert('PDF import failed. Try exporting the PDF as a PNG/JPG first, or use a smaller PDF.');
      } finally {
        UI.bgUpload.value = '';
      }
    });

    /* =========================================================
       SELECTION + EDIT
       ========================================================= */
    const getItem = (id)=>State.items.find(i=>i.id===id) || null;

    const clearSelection = ()=>State.selected.clear();
    const selectOnly = (id)=>{ State.selected.clear(); if (id) State.selected.add(id); };

    function updateSelectedPanel(){
      const ids = [...State.selected];
      if (ids.length === 1){
        const it = getItem(ids[0]);
        UI.selEmpty.classList.add('hide');
        UI.selPanel.classList.remove('hide');
        UI.selLabel.value = it.label || '';
        UI.selW.textContent = fmtFtIn(it.w);
        UI.selH.textContent = fmtFtIn(it.h);
        const allLocked = it.locked;
        UI.chipLock.classList.toggle('on', !!allLocked);
        buildColorChips(it.color || 'brand');
      } else {
        UI.selEmpty.classList.remove('hide');
        UI.selPanel.classList.add('hide');
      }
    }

    function buildColorChips(activeKey){
      UI.colorChips.innerHTML = '';
      for (const c of COLORS){
        const chip = document.createElement('div');
        chip.className = 'chip';
        chip.innerHTML = `<span class="swatch" style="background:${c.hex}"></span>${c.name}`;
        chip.classList.toggle('on', c.key === activeKey);
        chip.addEventListener('click', ()=>{
          const ids = [...State.selected];
          if (ids.length !== 1) return;
          History.push('color');
          const it = getItem(ids[0]);
          it.color = c.key;
          updateItemEl(it);
          updateSelectedPanel();
        });
        UI.colorChips.appendChild(chip);
      }
    }

    function deleteSelected(){
      const ids = new Set(State.selected);
      if (!ids.size) return;
      History.push('delete');
      State.items = State.items.filter(i=>!ids.has(i.id));
      clearSelection();
      renderItems();
      toast('Deleted');
    }

    function duplicateSelected(){
      const ids = [...State.selected];
      if (!ids.length) return;
      History.push('duplicate');
      const newIds = [];
      for (const id of ids){
        const src = getItem(id);
        const copy = deepCopy(src);
        copy.id = uid();
        copy.x += 20; copy.y += 20;
        State.items.push(copy);
        newIds.push(copy.id);
      }
      State.selected = new Set(newIds);
      renderItems();
      toast('Duplicated');
    }

    // Multi-lock: toggles all selected (if any unlocked -> lock all; else unlock all)
    function toggleLockSelected(){
      const ids = [...State.selected];
      if (!ids.length) return;
      History.push('lock');
      const items = ids.map(getItem).filter(Boolean);
      const anyUnlocked = items.some(it=>!it.locked);
      for (const it of items){ it.locked = anyUnlocked; updateItemEl(it); }
      updateSelectedPanel();
      toast(anyUnlocked ? 'Locked selected' : 'Unlocked selected');
    }

    function rotateSelectedBy(deg){
      const ids = [...State.selected];
      if (!ids.length) return;
      const items = ids.map(getItem).filter(Boolean).filter(it=>!it.locked);
      if (!items.length) return;
      History.push('rotate-step');
      for (const it of items){
        it.rot = normalizeAngle((it.rot || 0) + deg);
        updateItemEl(it);
      }
      updateSelectedPanel();
      toast(`Rotated ${items.length} by ${deg}¬∞`);
    }

    /* =========================================================
       ITEMS: CREATE
       ========================================================= */
    function addItem(type, at){
      const d = defByType(type);
      if (!d) return;
      History.push('add');
      const id = uid();
      const w = d.wFt * State.pxPerFt;
      const h = d.hFt * State.pxPerFt;
      const maxX = State.roomFt.w*State.pxPerFt - w;
      const maxY = State.roomFt.h*State.pxPerFt - h;
      const x = snapPx(clamp(at.x - w/2, 0, maxX));
      const y = snapPx(clamp(at.y - h/2, 0, maxY));
      State.items.push({ id, type, label:d.name, x,y, w,h, rot:0, locked:false, color:d.color||'brand' });
      selectOnly(id);
      renderItems();
      toast(`Added ${d.name}`);
    }

    function buildPalette(){
      UI.palette.innerHTML = '';
      UI.paletteMobile.innerHTML = '';
      for (const d of ObjectDefs){
        const mk = (container, onClick)=>{
          const tile = document.createElement('div');
          tile.className = 'tile';
          tile.innerHTML = `<div><div class="name">${d.name}</div><div class="note">${d.note||''}</div></div><div class="swatch" style="background:${colorHex(d.color||'brand')}"></div>`;
          tile.addEventListener('click', onClick);
          container.appendChild(tile);
        };
        mk(UI.palette, ()=> addItem(d.type, { x:(State.roomFt.w*State.pxPerFt)/2, y:(State.roomFt.h*State.pxPerFt)/2 }));
        mk(UI.paletteMobile, ()=>{ addItem(d.type, { x:(State.roomFt.w*State.pxPerFt)/2, y:(State.roomFt.h*State.pxPerFt)/2 }); closeSheet(); });
      }
    }

    /* =========================================================
       GEAR SUMMARY
       ========================================================= */
    function updateGear(){
      const counts = new Map();
      for (const it of State.items){
        if (it.type === 'speaker_pair'){ counts.set('Speakers', (counts.get('Speakers')||0) + 2); continue; }
        if (it.type === 'uplight'){ counts.set('Uplights', (counts.get('Uplights')||0) + 1); continue; }
        if (it.type === 'moving_head'){ counts.set('Moving Heads', (counts.get('Moving Heads')||0) + 1); continue; }
        const d = defByType(it.type);
        const key = d?.name || it.type;
        counts.set(key, (counts.get(key)||0) + 1);
      }

      if (!State.items.length){ UI.gear.textContent = 'No objects yet.'; return; }
      const lines = [];
      for (const [k,v] of [...counts.entries()].sort((a,b)=>a[0].localeCompare(b[0]))){
        lines.push(`‚Ä¢ ${k}: ${v}`);
      }
      UI.gear.textContent = lines.join('\n');
    }

    /* =========================================================
       INTERACTIONS
       ========================================================= */
    function setMode(m){ State.mode = m; }

    const Key = { space:false, shift:false };

    function isPanKey(){ return Key.space; }

    function nudgeSelected(dx, dy, big=false){
      const ids = [...State.selected];
      if (!ids.length) return;
      const step = (State.pxPerFt && State.pxPerFt > 0) ? (State.pxPerFt * (big ? 5 : 1)) : (big ? 20 : 5);
      const mx = dx * step;
      const my = dy * step;

      // Only nudge unlocked
      const items = ids.map(getItem).filter(Boolean).filter(it=>!it.locked);
      if (!items.length) return;

      History.push('nudge');

      for (const it of items){
        const maxX = State.roomFt.w*State.pxPerFt - it.w;
        const maxY = State.roomFt.h*State.pxPerFt - it.h;
        let nx = clamp(it.x + mx, 0, maxX);
        let ny = clamp(it.y + my, 0, maxY);
        it.x = State.snapOn ? snapPx(nx) : nx;
        it.y = State.snapOn ? snapPx(ny) : ny;
        updateItemEl(it);
      }
      updateSelectedPanel();
    }

    window.addEventListener('keydown', (e)=>{
      if (e.code === 'Space') Key.space = true;
      if (e.key === 'Shift') Key.shift = true;

      // Keyboard shortcuts should not fire while typing
      if (isEditableTarget(document.activeElement)) return;

      const isCmd = e.metaKey || e.ctrlKey;

      // Undo/redo
      if (isCmd && e.key.toLowerCase() === 'z'){
        e.preventDefault();
        if (e.shiftKey) History.redo();
        else History.undo();
        return;
      }

      // Duplicate
      if (isCmd && e.key.toLowerCase() === 'd'){
        e.preventDefault();
        duplicateSelected();
        return;
      }

      // Nudge
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)){
        e.preventDefault();
        const big = e.shiftKey;
        if (e.key === 'ArrowUp') nudgeSelected(0,-1,big);
        if (e.key === 'ArrowDown') nudgeSelected(0, 1,big);
        if (e.key === 'ArrowLeft') nudgeSelected(-1,0,big);
        if (e.key === 'ArrowRight') nudgeSelected(1,0,big);
        return;
      }

      if (e.key === 'Backspace' || e.key === 'Delete'){
        deleteSelected();
        return;
      }

      if (e.key.toLowerCase() === 'l'){
        toggleLockSelected();
        return;
      }

      if (e.key === 'Escape'){
        if (State.mode === 'setScale') cancelScaleTool();
        else if (State.ui.panTool) setActiveTool('none');
        else { clearSelection(); renderItems(); }
      }
    });

    window.addEventListener('keyup', (e)=>{
      if (e.code === 'Space') Key.space = false;
      if (e.key === 'Shift') Key.shift = false;
    });

    function setActiveTool(tool){
      // tool: 'none' | 'pan' | 'scale'
      if (tool === 'scale'){
        // scale wins, pan off
        State.ui.panTool = false;
        UI.hudPan.classList.remove('on');
        if (State.mode !== 'setScale'){
          State.scaleTool.step = 0;
          State.scaleTool.p1 = null;
          State.scaleTool.p2 = null;
          State.scaleTool.hover = null;
          setMode('setScale');
          UI.hudScale.classList.add('on');
          showScaleOverlay(true);
          toast('Scale: click first point');
        } else {
          cancelScaleTool();
        }
        return;
      }

      if (tool === 'pan'){
        // pan wins, scale off
        if (State.mode === 'setScale') cancelScaleTool();
        State.ui.panTool = !State.ui.panTool;
        UI.hudPan.classList.toggle('on', State.ui.panTool);
        toast(State.ui.panTool ? 'Pan tool on' : 'Pan tool off');
        return;
      }

      // none
      if (State.mode === 'setScale') cancelScaleTool();
      if (State.ui.panTool){
        State.ui.panTool = false;
        UI.hudPan.classList.remove('on');
      }
    }

    function showScaleOverlay(show){
      UI.scaleOverlay.style.display = show ? 'block' : 'none';
    }

    function cancelScaleTool(){
      State.scaleTool.step = 0;
      State.scaleTool.p1 = null;
      State.scaleTool.p2 = null;
      State.scaleTool.hover = null;
      showScaleOverlay(false);
      setMode('idle');
      UI.hudScale.classList.remove('on');
      toast('Scale off');
    }

    // Finish scale tool without extra toast (used after setting scale)
    function finishScaleTool(){
      State.scaleTool.step = 0;
      State.scaleTool.p1 = null;
      State.scaleTool.p2 = null;
      State.scaleTool.hover = null;
      showScaleOverlay(false);
      setMode('idle');
      UI.hudScale.classList.remove('on');
    }

    function updateScaleOverlay(){
      if (State.mode !== 'setScale') return;
      const p1 = State.scaleTool.p1;
      const p2Room = (State.scaleTool.step === 1) ? State.scaleTool.hover : State.scaleTool.p2;
      if (!p1 || !p2Room) return;

      // IMPORTANT: scale overlay is drawn in *screen* coordinates (viewport space),
      // but p1/p2 are in *room/world* coordinates. Convert using the current view.
      const toScreen = (p)=>({
        x: (p.x * State.view.zoom) + State.view.panX,
        y: (p.y * State.view.zoom) + State.view.panY,
      });

      const s1 = toScreen(p1);
      const s2 = toScreen(p2Room);

      showScaleOverlay(true);

      const len = Math.hypot(s2.x - s1.x, s2.y - s1.y);
      const ang = Math.atan2(s2.y - s1.y, s2.x - s1.x) * 180/Math.PI;

      UI.scaleLine.style.left = s1.x + 'px';
      UI.scaleLine.style.top  = s1.y + 'px';
      UI.scaleLine.style.width = len + 'px';
      UI.scaleLine.style.transform = `rotate(${ang}deg)`;

      UI.scaleDot1.style.left = s1.x + 'px';
      UI.scaleDot1.style.top  = s1.y + 'px';
      UI.scaleDot2.style.left = s2.x + 'px';
      UI.scaleDot2.style.top  = s2.y + 'px';

      const mid = { x:(s1.x+s2.x)/2, y:(s1.y+s2.y)/2 };
      UI.scaleLabelEl.style.left = mid.x + 'px';
      UI.scaleLabelEl.style.top  = mid.y + 'px';

      // Still display the *world* length using current pxPerFt (until user enters real ft)
      const worldLenPx = Math.hypot(p2Room.x - p1.x, p2Room.y - p1.y);
      UI.scaleLabelEl.textContent = `Line: ${fmtFtIn(worldLenPx)} (enter real ft)`;
    }

    function onItemPointerDown(e, id){
      e.preventDefault();
      const it = getItem(id);
      if (!it) return;

      const alreadySelected = State.selected.has(id);
      if (Key.shift){
        if (alreadySelected) State.selected.delete(id);
        else State.selected.add(id);
      } else {
        if (!alreadySelected || State.selected.size <= 1) selectOnly(id);
        // else keep multi-selection and drag the group
      }

      // If clicked item is locked, do not drag
      const clicked = getItem(id);
      if (clicked?.locked){ renderItems(); return; }

      setMode('dragging');
      State.pointer.id = e.pointerId;
      PointerCapture.safeCapture(e.pointerId, e.currentTarget);

      const p = screenToRoomPoint(e.clientX, e.clientY);

      // Drag group if multiple selected and this item is part of it
      const groupIds = (State.selected.size > 1 && State.selected.has(id)) ? [...State.selected] : [id];
      const group = groupIds.map(getItem).filter(Boolean).filter(x=>!x.locked);

      // If everything in group is locked, nothing to do
      if (!group.length){ renderItems(); return; }

      History.push('move');

      const orig = new Map();
      for (const g of group) orig.set(g.id, { x:g.x, y:g.y });

      State.drag = { kind:'move', ids: group.map(g=>g.id), start: { x: p.x, y: p.y }, orig };

      for (const gid of group.map(g=>g.id)){
        const rec = ItemEls.get(gid);
        if (rec) rec.root.classList.add('dragging');
      }

      renderItems();
    }

    function onHandleDown(e, id, corner){
      e.preventDefault();
      e.stopPropagation();
      const it = getItem(id);
      if (!it || it.locked) return;
      selectOnly(id);
      setMode('resizing');
      State.pointer.id = e.pointerId;
      PointerCapture.safeCapture(e.pointerId, e.currentTarget);
      const p = screenToRoomPoint(e.clientX, e.clientY);
      History.push('resize');
      State.drag = { kind:'resize', id, corner, start: { x:p.x, y:p.y }, orig: { x: it.x, y: it.y, w: it.w, h: it.h } };
      updateSelectedPanel();
    }

    function onRotateDown(e, id){
      e.preventDefault();
      e.stopPropagation();
      const it = getItem(id);
      if (!it || it.locked) return;
      selectOnly(id);
      setMode('rotating');
      State.pointer.id = e.pointerId;
      PointerCapture.safeCapture(e.pointerId, e.currentTarget);
      const p = screenToRoomPoint(e.clientX, e.clientY);
      const cx = it.x + it.w/2;
      const cy = it.y + it.h/2;
      const ang0 = Math.atan2(p.y - cy, p.x - cx) * 180/Math.PI;
      History.push('rotate');
      State.drag = { kind:'rotate', id, center:{x:cx,y:cy}, ang0, origRot: it.rot };
      updateSelectedPanel();
    }

    function updateGestureFromPointers(){
      const pts = [...State.gesture.pointers.values()];
      if (pts.length < 2) return;
      const a = pts[0];
      const b = pts[1];
      const mid = { x:(a.clientX+b.clientX)/2, y:(a.clientY+b.clientY)/2 };
      const d = Math.hypot(a.clientX-b.clientX, a.clientY-b.clientY);

      if (!State.gesture.active){
        State.gesture.active = true;
        State.gesture.startDist = d;
        State.gesture.startZoom = State.view.zoom;
        State.gesture.startPanX = State.view.panX;
        State.gesture.startPanY = State.view.panY;
        State.gesture.startMid = mid;
        return;
      }

      const factor = d / (State.gesture.startDist || d);
      const targetZoom = clamp(State.gesture.startZoom * factor, 0.25, 4);

      const dx = mid.x - State.gesture.startMid.x;
      const dy = mid.y - State.gesture.startMid.y;

      State.view.panX = State.gesture.startPanX + dx;
      State.view.panY = State.gesture.startPanY + dy;
      State.view.zoom = targetZoom;

      applyView();
    }

    UI.viewport.addEventListener('pointerdown', (e)=>{
      State.gesture.pointers.set(e.pointerId, { clientX:e.clientX, clientY:e.clientY });

      const isItem = e.target.closest && e.target.closest('.item');

      // Scale tool
      if (State.mode === 'setScale'){
        e.preventDefault();
        const p = screenToRoomPoint(e.clientX, e.clientY);
        if (State.scaleTool.step === 0){
          State.scaleTool.p1 = p;
          State.scaleTool.step = 1;
          State.scaleTool.hover = p;
          showScaleOverlay(true);
          updateScaleOverlay();
          toast('Scale: click second point');
        } else {
          State.scaleTool.p2 = p;
          const px = dist(State.scaleTool.p1, State.scaleTool.p2);
          const ft = prompt('Enter real-world length in feet (e.g., 20):', '20');
          const ftNum = parseFloat(ft||'');
          if (ftNum && ftNum > 0){
            History.push('scale');
            State.pxPerFt = px / ftNum;
            toast(`Scale set: 1ft = ${Math.round(State.pxPerFt)}px`);
            buildRulers();
            applyRoom();
          } else {
            toast('Scale cancelled');
          }
          finishScaleTool();
        }
        return;
      }

      // background move when unlocked
      if (State.bg.src && !State.bg.locked && !isItem && !isPanKey() && !State.ui.panTool && State.mode==='idle'){
        e.preventDefault();
        setMode('draggingBG');
        State.pointer.id = e.pointerId;
        PointerCapture.safeCapture(e.pointerId, e.currentTarget);
        const p = screenToRoomPoint(e.clientX, e.clientY);
        History.push('bg-move');
        State.drag = { kind:'bg', start:{x:p.x,y:p.y}, orig:{x:State.bg.x, y:State.bg.y} };
        return;
      }

      // click empty space clears selection
      if (!isItem){
        if (!Key.shift) clearSelection();
        renderItems();
      }

      // Pan with Space OR Pan tool
      if ((isPanKey() || State.ui.panTool) && !isItem){
        e.preventDefault();
        setMode('panning');
        State.pointer.id = e.pointerId;
        PointerCapture.safeCapture(e.pointerId, e.currentTarget);
        State.drag = { kind:'pan', lastX: e.clientX, lastY: e.clientY };
      }

      // 2 finger gesture
      if (State.gesture.pointers.size >= 2 && !isItem){
        e.preventDefault();
        setMode('gesturing');
      }
    });

    UI.viewport.addEventListener('pointermove', (e)=>{
      if (State.gesture.pointers.has(e.pointerId)){
        State.gesture.pointers.set(e.pointerId, { clientX:e.clientX, clientY:e.clientY });
      }

      // Scale hover line
      if (State.mode === 'setScale' && State.scaleTool.step === 1){
        const p = screenToRoomPoint(e.clientX, e.clientY);
        State.scaleTool.hover = p;
        updateScaleOverlay();
      }

      if (State.mode === 'gesturing'){
        updateGestureFromPointers();
        return;
      }

      if (State.pointer.id !== e.pointerId) return;

      if (State.mode === 'panning' && State.drag?.kind === 'pan'){
        const dx = e.clientX - State.drag.lastX;
        const dy = e.clientY - State.drag.lastY;
        State.drag.lastX = e.clientX;
        State.drag.lastY = e.clientY;
        State.view.panX += dx;
        State.view.panY += dy;
        applyView();
        return;
      }

      if (!State.drag) return;

      if (State.drag.kind === 'bg'){
        const p = screenToRoomPoint(e.clientX, e.clientY);
        const dx = p.x - State.drag.start.x;
        const dy = p.y - State.drag.start.y;
        State.bg.x = State.drag.orig.x + dx;
        State.bg.y = State.drag.orig.y + dy;
        renderBg();
        return;
      }

      if (State.drag.kind === 'move'){
        const p = screenToRoomPoint(e.clientX, e.clientY);
        const dx = p.x - State.drag.start.x;
        const dy = p.y - State.drag.start.y;

        for (const id of State.drag.ids){
          const it = getItem(id);
          if (!it) continue;
          const o = State.drag.orig.get(id);
          if (!o) continue;
          let nx = o.x + dx;
          let ny = o.y + dy;
          nx = clamp(nx, 0, State.roomFt.w*State.pxPerFt - it.w);
          ny = clamp(ny, 0, State.roomFt.h*State.pxPerFt - it.h);
          it.x = snapPx(nx);
          it.y = snapPx(ny);
          updateItemEl(it);
        }

        if (State.selected.size === 1){
          const only = getItem([...State.selected][0]);
          if (only){
            UI.selW.textContent = fmtFtIn(only.w);
            UI.selH.textContent = fmtFtIn(only.h);
          }
        }
        return;
      }

      const it = getItem(State.drag.id);
      if (!it) return;
      const p = screenToRoomPoint(e.clientX, e.clientY);

      if (State.drag.kind === 'resize'){
        const o = State.drag.orig;
        let nx=o.x, ny=o.y, nw=o.w, nh=o.h;
        const dx = p.x - State.drag.start.x;
        const dy = p.y - State.drag.start.y;
        const min = State.pxPerFt * 0.5;

        if (State.drag.corner==='br'){ nw = clamp(o.w + dx, min, State.roomFt.w*State.pxPerFt); nh = clamp(o.h + dy, min, State.roomFt.h*State.pxPerFt); }
        if (State.drag.corner==='tr'){ nw = clamp(o.w + dx, min, State.roomFt.w*State.pxPerFt); nh = clamp(o.h - dy, min, State.roomFt.h*State.pxPerFt); ny = o.y + (o.h - nh); }
        if (State.drag.corner==='bl'){ nw = clamp(o.w - dx, min, State.roomFt.w*State.pxPerFt); nh = clamp(o.h + dy, min, State.roomFt.h*State.pxPerFt); nx = o.x + (o.w - nw); }
        if (State.drag.corner==='tl'){ nw = clamp(o.w - dx, min, State.roomFt.w*State.pxPerFt); nh = clamp(o.h - dy, min, State.roomFt.h*State.pxPerFt); nx = o.x + (o.w - nw); ny = o.y + (o.h - nh); }

        nx = clamp(nx, 0, State.roomFt.w*State.pxPerFt - nw);
        ny = clamp(ny, 0, State.roomFt.h*State.pxPerFt - nh);
        it.x = snapPx(nx);
        it.y = snapPx(ny);
        it.w = Math.max(min, snapPx(nw));
        it.h = Math.max(min, snapPx(nh));
        updateItemEl(it);
        UI.selW.textContent = fmtFtIn(it.w);
        UI.selH.textContent = fmtFtIn(it.h);
      }

      if (State.drag.kind === 'rotate'){
        const cx = State.drag.center.x;
        const cy = State.drag.center.y;
        const ang = Math.atan2(p.y - cy, p.x - cx) * 180/Math.PI;
        it.rot = normalizeAngle(State.drag.origRot + (ang - State.drag.ang0));
        updateItemEl(it);
      }
    });

    function endInteraction(pointerId){
      PointerCapture.reset(pointerId);
      State.pointer.id = null;
      State.drag = null;
      if (State.mode !== 'setScale') setMode('idle');
      for (const rec of ItemEls.values()) rec.root.classList.remove('dragging');
      updateSelectedPanel();
      updateGear();
    }

    UI.viewport.addEventListener('pointerup', (e)=>{
      State.gesture.pointers.delete(e.pointerId);
      if (State.gesture.pointers.size < 2){
        State.gesture.active = false;
        if (State.mode === 'gesturing') setMode('idle');
      }
      if (State.pointer.id !== e.pointerId) return;
      endInteraction(e.pointerId);
    });

    UI.viewport.addEventListener('pointercancel', (e)=>{
      State.gesture.pointers.delete(e.pointerId);
      State.gesture.active = false;
      if (State.pointer.id !== e.pointerId) return;
      endInteraction(e.pointerId);
    });

    UI.viewport.addEventListener('wheel', (e)=>{
      // When BG is unlocked, wheel zooms the background (so uploaded PNGs are easy to fit)
      if (State.bg.src && !State.bg.locked){
        e.preventDefault();
        const factor = (e.deltaY < 0) ? 1.06 : 0.94;
        const p = screenToRoomPoint(e.clientX, e.clientY);
        // zoom around cursor point
        const old = State.bg.scale || 1;
        const next = clamp(old * factor, 0.05, 10);
        const sx = (p.x - State.bg.x) / old;
        const sy = (p.y - State.bg.y) / old;
        State.bg.scale = next;
        State.bg.x = p.x - sx * next;
        State.bg.y = p.y - sy * next;
        renderBg();
        return;
      }

      e.preventDefault();
      const factor = (e.deltaY < 0) ? 1.08 : 0.92;
      zoomAt(e.clientX, e.clientY, State.view.zoom * factor);
    }, { passive:false });

    /* =========================================================
       SAVE / LOAD
       ========================================================= */
    function getProject(){
      return {
        version: State.version,
        eventName: State.eventName,
        eventNotes: State.eventNotes,
        theme: State.theme,
        roomFt: State.roomFt,
        pxPerFt: State.pxPerFt,
        gridOn: State.gridOn,
        snapOn: State.snapOn,
        gridStepFt: State.gridStepFt,
        snapStepFt: State.snapStepFt,
        bg: State.bg,
        view: State.view,
        items: State.items,
      };
    }

    function loadProject(p){
      if (!p || typeof p !== 'object') return;
      History.push('before-load');

      State.version = p.version || 1;
      State.eventName = p.eventName || '';
      State.eventNotes = p.eventNotes || '';
      State.theme = p.theme || 'dark';
      State.roomFt = p.roomFt || {w:60,h:40};
      State.pxPerFt = p.pxPerFt || 40;
      State.gridOn = (p.gridOn !== undefined) ? p.gridOn : true;
      State.snapOn = (p.snapOn !== undefined) ? p.snapOn : true;
      State.gridStepFt = p.gridStepFt || 2;
      State.snapStepFt = p.snapStepFt || State.gridStepFt;
      State.bg = p.bg || State.bg;
      State.view = p.view || State.view;
      State.items = Array.isArray(p.items) ? p.items : [];
      clearSelection();

      UI.eventName.value = State.eventName;
      UI.eventNotes.value = State.eventNotes;
      UI.roomW.value = State.roomFt.w;
      UI.roomH.value = State.roomFt.h;
      UI.gridStep.value = String(State.gridStepFt);

      applyTheme();
      renderBg();
      applyRoom();
      applyView();
      renderItems();
      renderGrid();

      toast('Loaded');
    }

    function downloadProject(){
      const p = getProject();
      const name = safeFile(State.eventName || 'SleeveEvents_RoomPlan') || 'SleeveEvents_RoomPlan';
      // .sleeve is just JSON (so users can email it around), with a custom extension.
      const blob = new Blob([JSON.stringify(p, null, 2)], { type:'application/octet-stream' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `${name}.sleeve`;
      a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href), 800);
      toast('Downloaded .sleeve');
    }

    function uploadProject(){ UI.fileUpload.click(); }

    UI.fileUpload.addEventListener('change', async (e)=>{
      const f = e.target.files && e.target.files[0];
      if (!f) return;
      try{
        const txt = await f.text();
        loadProject(JSON.parse(txt));
      } catch(_){
        alert('Invalid .sleeve / JSON file');
      } finally {
        UI.fileUpload.value = '';
      }
    });

    function saveLocal(){
      History.push('save-local');
      localStorage.setItem('sleeve_room_planner_v1', JSON.stringify(getProject()));
      toast('Saved locally');
    }

    function loadLocal(){
      const txt = localStorage.getItem('sleeve_room_planner_v1');
      if (!txt){ toast('No local save'); return; }
      try{ loadProject(JSON.parse(txt)); }
      catch(_){ toast('Local save corrupted'); }
    }

    async function copyShareLink(){
      const url = encodeProjectToURL(getProject());
      try{ await navigator.clipboard.writeText(url); toast('Share link copied'); }
      catch(_){ prompt('Copy link:', url); }
    }

    /* =========================================================
       DEMOS
       ========================================================= */
    function demoWedding(){
      const p = getProject();
      p.eventName = 'Demo Wedding';
      p.eventNotes = 'Demo layout: tables, sweetheart table, DJ, dance floor, uplights.';
      p.roomFt = { w: 80, h: 50 };
      p.gridStepFt = 2;
      p.snapStepFt = 2;
      p.items = [];
      const px = p.pxPerFt;
      const add = (type, xFt, yFt, rot=0, label=null)=>{
        const d = defByType(type);
        p.items.push({ id: uid(), type, label: label || d.name, x:xFt*px, y:yFt*px, w:d.wFt*px, h:d.hFt*px, rot, locked:false, color:d.color });
      };
      add('dj_booth', 36, 6, 0);
      add('speaker_pair', 28, 6, 0, 'Speakers');
      add('dance_floor', 34, 16, 0);
      add('sweetheart', 36, 32, 0);
      add('photo_booth', 64, 10, 0);
      for (let r=0;r<3;r++) for (let c=0;c<5;c++) add('round_60', 10 + c*10, 10 + r*10, 0);
      for (let i=0;i<14;i++) add('uplight', 2 + i*5, 2);
      for (let i=0;i<10;i++) add('uplight', 2, 5 + i*4);
      for (let i=0;i<14;i++) add('uplight', 2 + i*5, 48);
      for (let i=0;i<10;i++) add('uplight', 78, 5 + i*4);
      loadProject(p);
      toast('Loaded demo wedding');
    }

    function demoMitzvah(){
      const p = getProject();
      p.eventName = 'Demo Bar Mitzvah';
      p.eventNotes = 'Demo layout: dance floor center, DJ & stage, lounge + tables.';
      p.roomFt = { w: 70, h: 45 };
      p.gridStepFt = 2;
      p.snapStepFt = 2;
      p.items = [];
      const px = p.pxPerFt;
      const add = (type, xFt, yFt, rot=0, label=null)=>{
        const d = defByType(type);
        p.items.push({ id: uid(), type, label: label || d.name, x:xFt*px, y:yFt*px, w:d.wFt*px, h:d.hFt*px, rot, locked:false, color:d.color });
      };
      add('stage', 28, 4);
      add('dj_booth', 32, 10);
      add('speaker_pair', 20, 10, 0, 'Speakers');
      add('dance_floor', 28, 18);
      add('photo_booth', 56, 8);
      add('bar', 50, 32);
      for (let r=0;r<2;r++) for (let c=0;c<4;c++) add('round_72', 8 + c*12, 30 + r*12);
      for (let i=0;i<6;i++) add('cocktail', 12 + i*6, 8);
      for (let i=0;i<6;i++) add('moving_head', 6 + i*10, 2);
      loadProject(p);
      toast('Loaded demo mitzvah');
    }

    /* =========================================================
       EXPORT
       ========================================================= */

    function roundRect(ctx, x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    function drawExportFooter(ctx, w, h, scale){
      const pad = 24 * scale;
      const fontSize = 16 * scale;
      ctx.save();
      ctx.globalAlpha = 0.88;
      ctx.fillStyle = State.theme === 'dark' ? 'rgba(0,0,0,.55)' : 'rgba(255,250,240,.92)';
      const boxH = 54 * scale;
      ctx.fillRect(0, h - boxH, w, boxH);
      ctx.globalAlpha = 1;
      ctx.fillStyle = State.theme === 'dark' ? 'rgba(255,255,255,.92)' : 'rgba(17,24,39,.92)';
      ctx.font = `900 ${fontSize}px ${getComputedStyle(document.body).fontFamily}`;
      ctx.textBaseline = 'middle';
      const y = h - (boxH/2);
      ctx.fillText(ExportBrand.site, pad, y);
      ctx.font = `800 ${Math.round(fontSize*0.88)}px ${getComputedStyle(document.body).fontFamily}`;
      const meta = `${ExportBrand.tagline}  ‚Ä¢  ${ExportBrand.email}`;
      const metaW = ctx.measureText(meta).width;
      ctx.fillText(meta, w - pad - metaW, y);
      ctx.restore();
    }

    async function ensureImageLoaded(img){
      if (!img || !img.src) return;
      if (img.complete && img.naturalWidth) return;
      await new Promise(res=>{ img.onload = ()=>res(); img.onerror=()=>res(); });
    }

    function drawItem(ctx, it){
  const d = defByType(it.type);
  const hex = colorHex(it.color || 'brand');

  // Match on-canvas object solidity (high opacity)
  const fillA = (State.theme==='dark') ? 0.86 : 0.80;

  ctx.save();
  const cx = it.x + it.w/2;
  const cy = it.y + it.h/2;
  ctx.translate(cx, cy);
  ctx.rotate((it.rot||0) * Math.PI/180);
  ctx.translate(-cx, -cy);

  // Fill (solid blocks)
  ctx.globalAlpha = 1;
  ctx.fillStyle = hexToRgba(hex, fillA);

  // Stroke (slightly darker in light mode, slightly lighter in dark mode)
  ctx.strokeStyle = State.theme==='dark' ? 'rgba(255,255,255,.20)' : 'rgba(17,24,39,.22)';
  ctx.lineWidth = 1;

  if (d?.shape === 'circle'){
    ctx.beginPath();
    ctx.ellipse(cx, cy, it.w/2, it.h/2, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();
  } else {
    roundRect(ctx, it.x, it.y, it.w, it.h, 12);
    ctx.fill();
    ctx.stroke();
  }

  // Label
  ctx.fillStyle = State.theme==='dark' ? 'rgba(255,255,255,.94)' : 'rgba(17,24,39,.94)';
  ctx.font = `900 12px ${getComputedStyle(document.body).fontFamily}`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  const label = it.label || d?.name || '';
  ctx.fillText(label, cx, cy);

  ctx.restore();
}

    async function exportPNG(){
      const scale = 2;
      const roomW = State.roomFt.w * State.pxPerFt;
      const roomH = State.roomFt.h * State.pxPerFt;
      const c = document.createElement('canvas');
      c.width = Math.round(roomW * scale);
      c.height = Math.round(roomH * scale);
      const ctx = c.getContext('2d');
      ctx.scale(scale, scale);

      ctx.fillStyle = State.theme === 'dark' ? '#ffffff' : '#fffaf0';
      ctx.fillRect(0,0,roomW,roomH);

      if (State.bg.src){
        await ensureImageLoaded(UI.bgImage);
        const iw = UI.bgImage.naturalWidth;
        const ih = UI.bgImage.naturalHeight;
        ctx.save();
        ctx.translate(State.bg.x, State.bg.y);
        ctx.scale(State.bg.scale, State.bg.scale);
        ctx.drawImage(UI.bgImage, 0, 0, iw, ih);
        ctx.restore();
      }

      if (State.gridOn){
        const step = State.gridStepFt * State.pxPerFt;
        ctx.save();
        ctx.strokeStyle = 'rgba(17,24,39,.06)';
        ctx.lineWidth = 1;
        for (let x=0; x<=roomW; x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,roomH); ctx.stroke(); }
        for (let y=0; y<=roomH; y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(roomW,y); ctx.stroke(); }
        ctx.restore();
      }

      ctx.save();
      ctx.strokeStyle = 'rgba(17,24,39,.25)';
      ctx.lineWidth = 2;
      roundRect(ctx, 0, 0, roomW, roomH, 14);
      ctx.stroke();
      ctx.restore();

      for (const it of State.items) drawItem(ctx, it);
      drawExportFooter(ctx, roomW, roomH, 1);

      const blob = await new Promise(res=>c.toBlob(res, 'image/png'));
      const name = safeFile(State.eventName || 'SleeveEvents_RoomPlan') || 'SleeveEvents_RoomPlan';
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `${name}.png`;
      a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href), 800);
      toast('Exported PNG');
    }

    function escapeHtml(str){ return String(str).replace(/[&<>\"']/g, s=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[s])); }

    async function exportPDF(){
      const scale = 2;
      const roomW = State.roomFt.w * State.pxPerFt;
      const roomH = State.roomFt.h * State.pxPerFt;
      const c = document.createElement('canvas');
      c.width = Math.round(roomW * scale);
      c.height = Math.round(roomH * scale);
      const ctx = c.getContext('2d');
      ctx.scale(scale, scale);

      ctx.fillStyle = State.theme === 'dark' ? '#ffffff' : '#fffaf0';
      ctx.fillRect(0,0,roomW,roomH);

      if (State.bg.src){
        await ensureImageLoaded(UI.bgImage);
        const iw = UI.bgImage.naturalWidth;
        const ih = UI.bgImage.naturalHeight;
        ctx.save();
        ctx.translate(State.bg.x, State.bg.y);
        ctx.scale(State.bg.scale, State.bg.scale);
        ctx.drawImage(UI.bgImage, 0, 0, iw, ih);
        ctx.restore();
      }

      if (State.gridOn){
        const step = State.gridStepFt * State.pxPerFt;
        ctx.save();
        ctx.strokeStyle = 'rgba(17,24,39,.06)';
        ctx.lineWidth = 1;
        for (let x=0; x<=roomW; x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,roomH); ctx.stroke(); }
        for (let y=0; y<=roomH; y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(roomW,y); ctx.stroke(); }
        ctx.restore();
      }

      ctx.save();
      ctx.strokeStyle = 'rgba(17,24,39,.25)';
      ctx.lineWidth = 2;
      roundRect(ctx, 0, 0, roomW, roomH, 14);
      ctx.stroke();
      ctx.restore();

      for (const it of State.items) drawItem(ctx, it);
      drawExportFooter(ctx, roomW, roomH, 1);

      const dataUrl = c.toDataURL('image/png');
      const win = window.open('', '_blank');
      if (!win){ alert('Popup blocked. Allow popups to export PDF.'); return; }
      const title = (State.eventName || 'Sleeve Events Room Plan');
      win.document.write(`<!doctype html><html><head><title>${escapeHtml(title)}</title>
        <style>
          html,body{ margin:0; padding:0; background:#fff; }
          .wrap{ padding: 24px; }
          img{ width:100%; height:auto; display:block; }
          .meta{ font-family: ui-sans-serif, system-ui; color:#111827; margin: 0 0 10px; }
          @media print{ .wrap{ padding:0; } }
        </style>
      </head><body>
        <div class="wrap">
          <div class="meta"><b>${escapeHtml(title)}</b></div>
          <img src="${dataUrl}" />
        </div>
        <script>window.onload=()=>{ setTimeout(()=>{ window.print(); }, 250); }<\/script>
      </body></html>`);
      win.document.close();
      toast('Opened print dialog');
    }

    /* =========================================================
       UI WIRING
       ========================================================= */
    function toggleTheme(){
      History.push('theme');
      State.theme = (State.theme === 'dark') ? 'light' : 'dark';
      applyTheme();
      renderItems();
      renderGrid();
      toast(State.theme === 'dark' ? 'Dark mode' : 'Light mode');
    }
    function toggleGrid(){ History.push('grid'); State.gridOn = !State.gridOn; renderGrid(); toast(State.gridOn ? 'Grid on' : 'Grid off'); }
    function toggleSnap(){ History.push('snap'); State.snapOn = !State.snapOn; renderGrid(); toast(State.snapOn ? 'Snap on' : 'Snap off'); }

    function openSheet(){ UI.sheetBackdrop.style.display = 'block'; UI.sheet.style.display = 'block'; document.body.classList.add('sheetOpen'); }
    function closeSheet(){ UI.sheetBackdrop.style.display = 'none'; UI.sheet.style.display = 'none'; document.body.classList.remove('sheetOpen'); }

    UI.btnSheetClose.addEventListener('click', closeSheet);
    UI.sheetBackdrop.addEventListener('click', closeSheet);
    UI.btnTools.addEventListener('click', openSheet);
    UI.fab.addEventListener('click', openSheet);

    UI.toggleTheme.addEventListener('click', toggleTheme);
    UI.toggleGrid.addEventListener('click', toggleGrid);
    UI.toggleSnap.addEventListener('click', toggleSnap);

    UI.btnUndo.addEventListener('click', ()=>History.undo());
    UI.btnRedo.addEventListener('click', ()=>History.redo());

    UI.hudPan.addEventListener('click', ()=>setActiveTool('pan'));
    UI.hudScale.addEventListener('click', ()=>setActiveTool('scale'));
    UI.hudFit.addEventListener('click', ()=>fitToView());

    UI.btnHelpHide.addEventListener('click', ()=>{ UI.help.style.display='none'; toast('Help hidden'); });

    // Prevent HUD/help clicks from triggering viewport tools
    UI.hud.addEventListener('pointerdown', (e)=>{ e.stopPropagation(); }, { capture:true });
    UI.help.addEventListener('pointerdown', (e)=>{ e.stopPropagation(); }, { capture:true });

    UI.eventName.addEventListener('input', ()=>{ State.eventName = UI.eventName.value; });
    UI.eventNotes.addEventListener('input', ()=>{ State.eventNotes = UI.eventNotes.value; });

    UI.gridStep.addEventListener('change', ()=>{
      History.push('grid-step');
      State.gridStepFt = parseFloat(UI.gridStep.value)||2;
      State.snapStepFt = State.gridStepFt;
      renderGrid();
      toast(`Grid ${State.gridStepFt}ft`);
    });

    UI.btnApplyRoom.addEventListener('click', ()=>{ History.push('room'); applyRoom(); toast('Room updated'); });

    function fitToView(){
      const roomW = State.roomFt.w * State.pxPerFt;
      const roomH = State.roomFt.h * State.pxPerFt;
      const rect = UI.viewport.getBoundingClientRect();
      const pad = 24;
      const zx = (rect.width - pad*2) / roomW;
      const zy = (rect.height - pad*2) / roomH;
      State.view.zoom = clamp(Math.min(zx, zy), 0.25, 3);
      State.view.panX = rect.width/2 - (roomW*State.view.zoom)/2;
      State.view.panY = rect.height/2 - (roomH*State.view.zoom)/2;
      applyView();
      toast('Fit view');
    }

    UI.btnFit.addEventListener('click', fitToView);

    UI.btnSetScale.addEventListener('click', ()=>setActiveTool('scale'));

    UI.btnClear.addEventListener('click', ()=>{
      if (!confirm('Clear all items?')) return;
      History.push('clear');
      State.items = [];
      clearSelection();
      renderItems();
      updateGear();
      toast('Cleared');
    });

    UI.btnBgUpload.addEventListener('click', ()=>UI.bgUpload.click());
    UI.btnBgFit.addEventListener('click', ()=>bgFit());

    UI.chipBgLock.addEventListener('click', ()=>{
      History.push('bg-lock');
      State.bg.locked = !State.bg.locked;
      renderBg();
      toast(State.bg.locked ? 'BG locked' : 'BG unlocked (drag to move + wheel/pinch to scale)');
    });
    UI.chipShowGrid.addEventListener('click', toggleGrid);
    UI.chipSnap.addEventListener('click', toggleSnap);

    UI.btnSaveLocal.addEventListener('click', saveLocal);
    UI.btnLoadLocal.addEventListener('click', loadLocal);
    UI.btnDownload.addEventListener('click', downloadProject);
    UI.btnUpload.addEventListener('click', uploadProject);
    UI.btnShare.addEventListener('click', copyShareLink);
    UI.btnExportPNG.addEventListener('click', exportPNG);
    UI.btnExportPDF.addEventListener('click', exportPDF);

    UI.selLabel.addEventListener('input', ()=>{
      const ids = [...State.selected];
      if (ids.length !== 1) return;
      History.push('label');
      const it = getItem(ids[0]);
      it.label = UI.selLabel.value;
      updateItemEl(it);
    });

    UI.chipLock.addEventListener('click', toggleLockSelected);
    UI.chipDuplicate.addEventListener('click', duplicateSelected);
    UI.chipRotL.addEventListener('click', ()=>rotateSelectedBy(-45));
    UI.chipRotR.addEventListener('click', ()=>rotateSelectedBy(45));
    UI.chipDelete.addEventListener('click', deleteSelected);

    UI.mUndo.addEventListener('click', ()=>History.undo());
    UI.mRedo.addEventListener('click', ()=>History.redo());

    UI.mSetScale.addEventListener('click', ()=>{ closeSheet(); UI.btnSetScale.click(); });
    UI.mFit.addEventListener('click', ()=>{ closeSheet(); fitToView(); });
    UI.mBgUpload.addEventListener('click', ()=>{ closeSheet(); UI.btnBgUpload.click(); });
    UI.mBgFit.addEventListener('click', ()=>{ closeSheet(); bgFit(); });
    UI.mDemoWedding.addEventListener('click', ()=>{ closeSheet(); demoWedding(); });
    UI.mDemoMitzvah.addEventListener('click', ()=>{ closeSheet(); demoMitzvah(); });
    UI.mExportPNG.addEventListener('click', ()=>{ closeSheet(); exportPNG(); });
    UI.mExportPDF.addEventListener('click', ()=>{ closeSheet(); exportPDF(); });
    UI.mShare.addEventListener('click', ()=>{ copyShareLink(); });
    UI.mDownload.addEventListener('click', ()=>{ downloadProject(); });
    UI.mSaveLocal.addEventListener('click', ()=>{ saveLocal(); });
    UI.mLoadLocal.addEventListener('click', ()=>{ loadLocal(); });
    UI.mUpload.addEventListener('click', ()=>{ uploadProject(); });
    UI.mClear.addEventListener('click', ()=>{ UI.btnClear.click(); });

    /* =========================================================
       iOS SCROLL SAFETY
       ========================================================= */
    let touchStartInViewport = false;
    const isIn = (el, selector)=> !!(el && el.closest && el.closest(selector));

    document.addEventListener('touchstart', (e)=>{
      const t = e.target;
      const inViewport = isIn(t, '#viewport');
      const inSheet = isIn(t, '#sheet');
      const inSidebar = isIn(t, '#sidebar');
      touchStartInViewport = inViewport && !inSheet && !inSidebar;
    }, { passive:true, capture:true });

    document.addEventListener('touchmove', (e)=>{
      if (!touchStartInViewport) return;
      if (!e.cancelable) return;
      const t = e.target;
      if (isIn(t, '#sheet') || isIn(t, '#sidebar')) return;
      e.preventDefault();
    }, { passive:false, capture:true });

    document.addEventListener('touchend', ()=>{ touchStartInViewport = false; }, { passive:true, capture:true });
    document.addEventListener('touchcancel', ()=>{ touchStartInViewport = false; }, { passive:true, capture:true });

    /* =========================================================
       TESTS
       ========================================================= */
    function runTests(){
      const assert = (cond, msg) => { if (!cond) throw new Error('Test failed: ' + msg); };
      assert(normalizeAngle(0) === 0, 'normalizeAngle 0');
      assert(normalizeAngle(360) === 0, 'normalizeAngle 360');
      assert(normalizeAngle(-10) === 350, 'normalizeAngle -10');
      assert(safeFile('Hello World!') === 'Hello_World_', 'safeFile basic');
      assert(safeFile('') === '', 'safeFile empty');
      const prevSnap = State.snapOn;
      const prevScale = State.pxPerFt;
      State.snapOn = false; State.pxPerFt = 40;
      assert(snapPx(53) === 53, 'snapPx off');
      State.snapOn = true; State.snapStepFt = 1;
      assert(snapPx(53) === 40, 'snapPx on rounds');
      State.snapOn = prevSnap; State.pxPerFt = prevScale;
      assert(PointerCapture.safeCapture(null, document.body) === false, 'PointerCapture null pointerId');
      assert(PointerCapture.safeCapture(1, null) === false, 'PointerCapture null element');
      // Undo/redo basic
      const before = History.snapshot();
      History.push('test');
      State.eventName = 'X';
      History.push('test2');
      History.undo();
      assert(State.eventName === before.eventName, 'undo restores state');
      History.redo();
      assert(State.eventName === 'X', 'redo restores state');
      console.log('[Sleeve Planner] Tests OK');
    }

    /* =========================================================
       INIT
       ========================================================= */
    function init(){
      buildPalette();

      const fromUrl = decodeProjectFromURL();
      if (fromUrl){
        loadProject(fromUrl);
        history.replaceState(null, '', location.pathname + location.search);
      } else {
        State.eventName = UI.eventName.value;
        State.eventNotes = UI.eventNotes.value;
        State.gridStepFt = parseFloat(UI.gridStep.value)||2;
        State.snapStepFt = State.gridStepFt;
        applyTheme();
        applyRoom();
        applyView();
        fitToView();
        renderItems();
        renderBg();
        renderGrid();
        updateInfiniteGrid();
        updateGear();
        updateScaleNote();
      }

      // Seed history with initial state
      History.push('init');
      updateUndoRedoButtons();

      if (window.innerWidth <= 560){ UI.help.style.display = 'none'; }
      if (location.search.includes('test=1')){
        try{ runTests(); } catch(err){ console.error(err); alert(err.message); }
      }
    }

    init();
  </script>
</body>
</html>
